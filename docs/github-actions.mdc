---
title: GitHub Actions Complete Pipeline Reference
provider: GitHub Actions
generated_at: 2025-07-08T14:41:58.616Z
pages_included: 10
---

# GitHub Actions Complete Pipeline Reference

This comprehensive guide contains all pipeline, workflow, and build configuration documentation for GitHub Actions.

## Table of Contents


1. [Workflow syntax for GitHub Actions](#section-1)
2. [Events that trigger workflows](#section-2)
3. [Using jobs in a workflow](#section-3)
4. [Reusing workflows](#section-4)
5. [Building and testing Swift](#section-5)
6. [Building and testing Java with Gradle](#section-6)
7. [Deploying with GitHub Actions](#section-7)
8. [Storing and sharing data from a workflow](#section-8)
9. [Use cases and examples](#section-9)
10. [Building and testing Node.js](#section-10)


---


## 1. Workflow syntax for GitHub Actions {#section-1}

*Source: [https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions)*


# Workflow syntax for GitHub Actions

A workflow is a configurable automated process made up of one or more jobs. You must create a YAML file to define your workflow configuration.

## In this article

## [About YAML syntax for workflows](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#about-yaml-syntax-for-workflows)

Workflow files use YAML syntax, and must have either a `.yml` or `.yaml` file extension. If you're new to YAML and want to learn more, see [Learn YAML in Y minutes](https://learnxinyminutes.com/docs/yaml/).

You must store workflow files in the `.github/workflows` directory of your repository.

## [`name`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#name)

The name of the workflow. GitHub displays the names of your workflows under your repository's "Actions" tab. If you omit `name`, GitHub displays the workflow file path relative to the root of the repository.

## [`run-name`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#run-name)

The name for workflow runs generated from the workflow. GitHub displays the workflow run name in the list of workflow runs on your repository's "Actions" tab. If `run-name` is omitted or is only whitespace, then the run name is set to event-specific information for the workflow run. For example, for a workflow triggered by a `push` or `pull_request` event, it is set as the commit message or the title of the pull request.

This value can include expressions and can reference the [`github`](https://docs.github.com/en/actions/learn-github-actions/contexts#github-context) and [`inputs`](https://docs.github.com/en/actions/learn-github-actions/contexts#inputs-context) contexts.

### [Example of `run-name`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-of-run-name)

```hljs yaml
run-name: Deploy to ${{ inputs.deploy_target }} by @${{ github.actor }}

```

## [`on`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#on)

To automatically trigger a workflow, use `on` to define which events can cause the workflow to run. For a list of available events, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows).

You can define single or multiple events that can trigger a workflow, or set a time schedule. You can also restrict the execution of a workflow to only occur for specific files, tags, or branch changes. These options are described in the following sections.

### [Using a single event](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#using-a-single-event)

For example, a workflow with the following `on` value will run when a push is made to any branch in the workflow's repository:

```hljs yaml
on: push

```

### [Using multiple events](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#using-multiple-events)

You can specify a single event or multiple events. For example, a workflow with the following `on` value will run when a push is made to any branch in the repository or when someone forks the repository:

```hljs yaml
on: [push, fork]

```

If you specify multiple events, only one of those events needs to occur to trigger your workflow. If multiple triggering events for your workflow occur at the same time, multiple workflow runs will be triggered.

### [Using activity types](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#using-activity-types)

Some events have activity types that give you more control over when your workflow should run. Use `on.<event_name>.types` to define the type of event activity that will trigger a workflow run.

For example, the `issue_comment` event has the `created`, `edited`, and `deleted` activity types. If your workflow triggers on the `label` event, it will run whenever a label is created, edited, or deleted. If you specify the `created` activity type for the `label` event, your workflow will run when a label is created but not when a label is edited or deleted.

```hljs yaml
on:
  label:
    types:
      - created

```

If you specify multiple activity types, only one of those event activity types needs to occur to trigger your workflow. If multiple triggering event activity types for your workflow occur at the same time, multiple workflow runs will be triggered. For example, the following workflow triggers when an issue is opened or labeled. If an issue with two labels is opened, three workflow runs will start: one for the issue opened event and two for the two issue labeled events.

```hljs yaml
on:
  issues:
    types:
      - opened
      - labeled

```

For more information about each event and their activity types, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows).

### [Using filters](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#using-filters)

Some events have filters that give you more control over when your workflow should run.

For example, the `push` event has a `branches` filter that causes your workflow to run only when a push to a branch that matches the `branches` filter occurs, instead of when any push occurs.

```hljs yaml
on:
  push:
    branches:
      - main
      - 'releases/**'

```

### [Using activity types and filters with multiple events](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#using-activity-types-and-filters-with-multiple-events)

If you specify activity types or filters for an event and your workflow triggers on multiple events, you must configure each event separately. You must append a colon ( `:`) to all events, including events without configuration.

For example, a workflow with the following `on` value will run when:

- A label is created
- A push is made to the `main` branch in the repository
- A push is made to a GitHub Pages-enabled branch

```hljs yaml
on:
  label:
    types:
      - created
  push:
    branches:
      - main
  page_build:

```

## [`on.<event_name>.types`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#onevent_nametypes)

Use `on.<event_name>.types` to define the type of activity that will trigger a workflow run. Most GitHub events are triggered by more than one type of activity. For example, the `label` is triggered when a label is `created`, `edited`, or `deleted`. The `types` keyword enables you to narrow down activity that causes the workflow to run. When only one activity type triggers a webhook event, the `types` keyword is unnecessary.

You can use an array of event `types`. For more information about each event and their activity types, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#available-events).

```hljs yaml
on:
  label:
    types: [created, edited]

```

## [`on.<pull_request|pull_request_target>.<branches|branches-ignore>`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#onpull_requestpull_request_targetbranchesbranches-ignore)

When using the `pull_request` and `pull_request_target` events, you can configure a workflow to run only for pull requests that target specific branches.

Use the `branches` filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the `branches-ignore` filter when you only want to exclude branch name patterns. You cannot use both the `branches` and `branches-ignore` filters for the same event in a workflow.

If you define both `branches`/ `branches-ignore` and [`paths`/ `paths-ignore`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore), the workflow will only run when both filters are satisfied.

The `branches` and `branches-ignore` keywords accept glob patterns that use characters like `*`, `**`, `+`, `?`, `!` and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with `\`. For more information about glob patterns, see the [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet).

### [Example: Including branches](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-including-branches)

The patterns defined in `branches` are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a `pull_request` event for a pull request targeting:

- A branch named `main` ( `refs/heads/main`)
- A branch named `mona/octocat` ( `refs/heads/mona/octocat`)
- A branch whose name starts with `releases/`, like `releases/10` ( `refs/heads/releases/10`)

```hljs yaml
on:
  pull_request:
    # Sequence of patterns matched against refs/heads
    branches:
      - main
      - 'mona/octocat'
      - 'releases/**'

```

If a workflow is skipped due to branch filtering, [path filtering](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore), or a [commit message](https://docs.github.com/en/actions/managing-workflow-runs/skipping-workflow-runs), then checks associated with that workflow will remain in a "Pending" state. A pull request that requires those checks to be successful will be blocked from merging.

### [Example: Excluding branches](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-excluding-branches)

When a pattern matches the `branches-ignore` pattern, the workflow will not run. The patterns defined in `branches-ignore` are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a `pull_request` event unless the pull request is targeting:

- A branch named `mona/octocat` ( `refs/heads/mona/octocat`)
- A branch whose name matches `releases/**-alpha`, like `releases/beta/3-alpha` ( `refs/heads/releases/beta/3-alpha`)

```hljs yaml
on:
  pull_request:
    # Sequence of patterns matched against refs/heads
    branches-ignore:
      - 'mona/octocat'
      - 'releases/**-alpha'

```

### [Example: Including and excluding branches](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-including-and-excluding-branches)

You cannot use `branches` and `branches-ignore` to filter the same event in a single workflow. If you want to both include and exclude branch patterns for a single event, use the `branches` filter along with the `!` character to indicate which branches should be excluded.

If you define a branch with the `!` character, you must also define at least one branch without the `!` character. If you only want to exclude branches, use `branches-ignore` instead.

The order that you define patterns matters.

- A matching negative pattern (prefixed with `!`) after a positive match will exclude the Git ref.
- A matching positive pattern after a negative match will include the Git ref again.

The following workflow will run on `pull_request` events for pull requests that target `releases/10` or `releases/beta/mona`, but not for pull requests that target `releases/10-alpha` or `releases/beta/3-alpha` because the negative pattern `!releases/**-alpha` follows the positive pattern.

```hljs yaml
on:
  pull_request:
    branches:
      - 'releases/**'
      - '!releases/**-alpha'

```

## [`on.push.<branches|tags|branches-ignore|tags-ignore>`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#onpushbranchestagsbranches-ignoretags-ignore)

When using the `push` event, you can configure a workflow to run on specific branches or tags.

Use the `branches` filter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use the `branches-ignore` filter when you only want to exclude branch name patterns. You cannot use both the `branches` and `branches-ignore` filters for the same event in a workflow.

Use the `tags` filter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. Use the `tags-ignore` filter when you only want to exclude tag name patterns. You cannot use both the `tags` and `tags-ignore` filters for the same event in a workflow.

If you define only `tags`/ `tags-ignore` or only `branches`/ `branches-ignore`, the workflow won't run for events affecting the undefined Git ref. If you define neither `tags`/ `tags-ignore` or `branches`/ `branches-ignore`, the workflow will run for events affecting either branches or tags. If you define both `branches`/ `branches-ignore` and [`paths`/ `paths-ignore`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore), the workflow will only run when both filters are satisfied.

The `branches`, `branches-ignore`, `tags`, and `tags-ignore` keywords accept glob patterns that use characters like `*`, `**`, `+`, `?`, `!` and others to match more than one branch or tag name. If a name contains any of these characters and you want a literal match, you need to _escape_ each of these special characters with `\`. For more information about glob patterns, see the [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet).

### [Example: Including branches and tags](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-including-branches-and-tags)

The patterns defined in `branches` and `tags` are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a `push` event to:

- A branch named `main` ( `refs/heads/main`)
- A branch named `mona/octocat` ( `refs/heads/mona/octocat`)
- A branch whose name starts with `releases/`, like `releases/10` ( `refs/heads/releases/10`)
- A tag named `v2` ( `refs/tags/v2`)
- A tag whose name starts with `v1.`, like `v1.9.1` ( `refs/tags/v1.9.1`)

```hljs yaml
on:
  push:
    # Sequence of patterns matched against refs/heads
    branches:
      - main
      - 'mona/octocat'
      - 'releases/**'
    # Sequence of patterns matched against refs/tags
    tags:
      - v2
      - v1.*

```

### [Example: Excluding branches and tags](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-excluding-branches-and-tags)

When a pattern matches the `branches-ignore` or `tags-ignore` pattern, the workflow will not run. The patterns defined in `branches` and `tags` are evaluated against the Git ref's name. For example, the following workflow would run whenever there is a `push` event, unless the `push` event is to:

- A branch named `mona/octocat` ( `refs/heads/mona/octocat`)
- A branch whose name matches `releases/**-alpha`, like `releases/beta/3-alpha` ( `refs/heads/releases/beta/3-alpha`)
- A tag named `v2` ( `refs/tags/v2`)
- A tag whose name starts with `v1.`, like `v1.9` ( `refs/tags/v1.9`)

```hljs yaml
on:
  push:
    # Sequence of patterns matched against refs/heads
    branches-ignore:
      - 'mona/octocat'
      - 'releases/**-alpha'
    # Sequence of patterns matched against refs/tags
    tags-ignore:
      - v2
      - v1.*

```

### [Example: Including and excluding branches and tags](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-including-and-excluding-branches-and-tags)

You can't use `branches` and `branches-ignore` to filter the same event in a single workflow. Similarly, you can't use `tags` and `tags-ignore` to filter the same event in a single workflow. If you want to both include and exclude branch or tag patterns for a single event, use the `branches` or `tags` filter along with the `!` character to indicate which branches or tags should be excluded.

If you define a branch with the `!` character, you must also define at least one branch without the `!` character. If you only want to exclude branches, use `branches-ignore` instead. Similarly, if you define a tag with the `!` character, you must also define at least one tag without the `!` character. If you only want to exclude tags, use `tags-ignore` instead.

The order that you define patterns matters.

- A matching negative pattern (prefixed with `!`) after a positive match will exclude the Git ref.
- A matching positive pattern after a negative match will include the Git ref again.

The following workflow will run on pushes to `releases/10` or `releases/beta/mona`, but not on `releases/10-alpha` or `releases/beta/3-alpha` because the negative pattern `!releases/**-alpha` follows the positive pattern.

```hljs yaml
on:
  push:
    branches:
      - 'releases/**'
      - '!releases/**-alpha'

```

## [`on.<push|pull_request|pull_request_target>.<paths|paths-ignore>`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#onpushpull_requestpull_request_targetpathspaths-ignore)

When using the `push` and `pull_request` events, you can configure a workflow to run based on what file paths are changed. Path filters are not evaluated for pushes of tags.

Use the `paths` filter when you want to include file path patterns or when you want to both include and exclude file path patterns. Use the `paths-ignore` filter when you only want to exclude file path patterns. You cannot use both the `paths` and `paths-ignore` filters for the same event in a workflow. If you want to both include and exclude path patterns for a single event, use the `paths` filter prefixed with the `!` character to indicate which paths should be excluded.

Note

The order that you define `paths` patterns matters:

- A matching negative pattern (prefixed with `!`) after a positive match will exclude the path.
- A matching positive pattern after a negative match will include the path again.

If you define both `branches`/ `branches-ignore` and `paths`/ `paths-ignore`, the workflow will only run when both filters are satisfied.

The `paths` and `paths-ignore` keywords accept glob patterns that use the `*` and `**` wildcard characters to match more than one path name. For more information, see the [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet).

### [Example: Including paths](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-including-paths)

If at least one path matches a pattern in the `paths` filter, the workflow runs. For example, the following workflow would run anytime you push a JavaScript file ( `.js`).

```hljs yaml
on:
  push:
    paths:
      - '**.js'

```

If a workflow is skipped due to path filtering, [branch filtering](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpull_requestpull_request_targetbranchesbranches-ignore), or a [commit message](https://docs.github.com/en/actions/managing-workflow-runs/skipping-workflow-runs), then checks associated with that workflow will remain in a "Pending" state. A pull request that requires those checks to be successful will be blocked from merging.

### [Example: Excluding paths](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-excluding-paths)

When all the path names match patterns in `paths-ignore`, the workflow will not run. If any path names do not match patterns in `paths-ignore`, even if some path names match the patterns, the workflow will run.

A workflow with the following path filter will only run on `push` events that include at least one file outside the `docs` directory at the root of the repository.

```hljs yaml
on:
  push:
    paths-ignore:
      - 'docs/**'

```

### [Example: Including and excluding paths](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-including-and-excluding-paths)

You cannot use `paths` and `paths-ignore` to filter the same event in a single workflow. If you want to both include and exclude path patterns for a single event, use the `paths` filter prefixed with the `!` character to indicate which paths should be excluded.

If you define a path with the `!` character, you must also define at least one path without the `!` character. If you only want to exclude paths, use `paths-ignore` instead.

The order that you define `paths` patterns matters:

- A matching negative pattern (prefixed with `!`) after a positive match will exclude the path.
- A matching positive pattern after a negative match will include the path again.

This example runs anytime the `push` event includes a file in the `sub-project` directory or its subdirectories, unless the file is in the `sub-project/docs` directory. For example, a push that changed `sub-project/index.js` or `sub-project/src/index.js` will trigger a workflow run, but a push changing only `sub-project/docs/readme.md` will not.

```hljs yaml
on:
  push:
    paths:
      - 'sub-project/**'
      - '!sub-project/docs/**'

```

### [Git diff comparisons](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#git-diff-comparisons)

Note

If you push more than 1,000 commits, or if GitHub does not generate the diff due to a timeout, the workflow will always run.

The filter determines if a workflow should run by evaluating the changed files and running them against the `paths-ignore` or `paths` list. If there are no files changed, the workflow will not run.

GitHub generates the list of changed files using two-dot diffs for pushes and three-dot diffs for pull requests:

- **Pull requests:** Three-dot diffs are a comparison between the most recent version of the topic branch and the commit where the topic branch was last synced with the base branch.
- **Pushes to existing branches:** A two-dot diff compares the head and base SHAs directly with each other.
- **Pushes to new branches:** A two-dot diff against the parent of the ancestor of the deepest commit pushed.

Note

Diffs are limited to 300 files. If there are files changed that aren't matched in the first 300 files returned by the filter, the workflow will not run. You may need to create more specific filters so that the workflow will run automatically.

For more information, see [About comparing branches in pull requests](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-comparing-branches-in-pull-requests).

## [`on.schedule`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#onschedule)

You can use `on.schedule` to define a time schedule for your workflows. You can schedule a workflow to run at specific UTC times using [POSIX cron syntax](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/crontab.html#tag_20_25_07). Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes.

This example triggers the workflow every day at 5:30 and 17:30 UTC:

```hljs yaml
on:
  schedule:
    # * is a special character in YAML so you have to quote this string
    - cron:  '30 5,17 * * *'

```

A single workflow can be triggered by multiple `schedule` events. You can access the schedule event that triggered the workflow through the `github.event.schedule` context. This example triggers the workflow to run at 5:30 UTC every Monday-Thursday, but skips the `Not on Monday or Wednesday` step on Monday and Wednesday.

```hljs yaml
on:
  schedule:
    - cron: '30 5 * * 1,3'
    - cron: '30 5 * * 2,4'

jobs:
  test_schedule:
    runs-on: ubuntu-latest
    steps:
      - name: Not on Monday or Wednesday
        if: github.event.schedule != '30 5 * * 1,3'
        run: echo "This step will be skipped on Monday and Wednesday"
      - name: Every time
        run: echo "This step will always run"

```

For more information about cron syntax, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#scheduled-events).

## [`on.workflow_call`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#onworkflow_call)

Use `on.workflow_call` to define the inputs and outputs for a reusable workflow. You can also map the secrets that are available to the called workflow. For more information on reusable workflows, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).

## [`on.workflow_call.inputs`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#onworkflow_callinputs)

When using the `workflow_call` keyword, you can optionally specify inputs that are passed to the called workflow from the caller workflow. For more information about the `workflow_call` keyword, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow-reuse-events).

In addition to the standard input parameters that are available, `on.workflow_call.inputs` requires a `type` parameter. For more information, see [`on.workflow_call.inputs.<input_id>.type`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#onworkflow_callinputsinput_idtype).

If a `default` parameter is not set, the default value of the input is `false` for a boolean, `0` for a number, and `""` for a string.

Within the called workflow, you can use the `inputs` context to refer to an input. For more information, see [Contexts reference](https://docs.github.com/en/actions/learn-github-actions/contexts#inputs-context).

If a caller workflow passes an input that is not specified in the called workflow, this results in an error.

### [Example of `on.workflow_call.inputs`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-of-onworkflow_callinputs)

```hljs yaml
on:
  workflow_call:
    inputs:
      username:
        description: 'A username passed from the caller workflow'
        default: 'john-doe'
        required: false
        type: string

jobs:
  print-username:
    runs-on: ubuntu-latest

    steps:
      - name: Print the input name to STDOUT
        run: echo The username is ${{ inputs.username }}

```

For more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).

## [`on.workflow_call.inputs.<input_id>.type`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#onworkflow_callinputsinput_idtype)

Required if input is defined for the `on.workflow_call` keyword. The value of this parameter is a string specifying the data type of the input. This must be one of: `boolean`, `number`, or `string`.

## [`on.workflow_call.outputs`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#onworkflow_calloutputs)

A map of outputs for a called workflow. Called workflow outputs are available to all downstream jobs in the caller workflow. Each output has an identifier, an optional `description,` and a `value.` The `value` must be set to the value of an output from a job within the called workflow.

In the example below, two outputs are defined for this reusable workflow: `workflow_output1` and `workflow_output2`. These are mapped to outputs called `job_output1` and `job_output2`, both from a job called `my_job`.

### [Example of `on.workflow_call.outputs`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-of-onworkflow_calloutputs)

```hljs yaml
on:
  workflow_call:
    # Map the workflow outputs to job outputs
    outputs:
      workflow_output1:
        description: "The first job output"
        value: ${{ jobs.my_job.outputs.job_output1 }}
      workflow_output2:
        description: "The second job output"
        value: ${{ jobs.my_job.outputs.job_output2 }}

```

For information on how to reference a job output, see [`jobs.<job_id>.outputs`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idoutputs). For more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).

## [`on.workflow_call.secrets`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#onworkflow_callsecrets)

A map of the secrets that can be used in the called workflow.

Within the called workflow, you can use the `secrets` context to refer to a secret.

Note

If you are passing the secret to a nested reusable workflow, then you must use [`jobs.<job_id>.secrets`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idsecrets) again to pass the secret. For more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows#passing-secrets-to-nested-workflows).

If a caller workflow passes a secret that is not specified in the called workflow, this results in an error.

### [Example of `on.workflow_call.secrets`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-of-onworkflow_callsecrets)

```hljs yaml
on:
  workflow_call:
    secrets:
      access-token:
        description: 'A token passed from the caller workflow'
        required: false

jobs:

  pass-secret-to-action:
    runs-on: ubuntu-latest
    steps:
    # passing the secret to an action
      - name: Pass the received secret to an action
        uses: ./.github/actions/my-action
        with:
          token: ${{ secrets.access-token }}

  # passing the secret to a nested reusable workflow
  pass-secret-to-workflow:
    uses: ./.github/workflows/my-workflow
    secrets:
       token: ${{ secrets.access-token }}

```

## [`on.workflow_call.secrets.<secret_id>`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#onworkflow_callsecretssecret_id)

A string identifier to associate with the secret.

## [`on.workflow_call.secrets.<secret_id>.required`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#onworkflow_callsecretssecret_idrequired)

A boolean specifying whether the secret must be supplied.

## [`on.workflow_run.<branches|branches-ignore>`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#onworkflow_runbranchesbranches-ignore)

When using the `workflow_run` event, you can specify what branches the triggering workflow must run on in order to trigger your workflow.

The `branches` and `branches-ignore` filters accept glob patterns that use characters like `*`, `**`, `+`, `?`, `!` and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to _escape_ each of these special characters with `\`. For more information about glob patterns, see the [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet).

For example, a workflow with the following trigger will only run when the workflow named `Build` runs on a branch whose name starts with `releases/`:

```hljs yaml
on:
  workflow_run:
    workflows: ["Build"]
    types: [requested]
    branches:
      - 'releases/**'

```

A workflow with the following trigger will only run when the workflow named `Build` runs on a branch that is not named `canary`:

```hljs yaml
on:
  workflow_run:
    workflows: ["Build"]
    types: [requested]
    branches-ignore:
      - "canary"

```

You cannot use both the `branches` and `branches-ignore` filters for the same event in a workflow. If you want to both include and exclude branch patterns for a single event, use the `branches` filter along with the `!` character to indicate which branches should be excluded.

The order that you define patterns matters.

- A matching negative pattern (prefixed with `!`) after a positive match will exclude the branch.
- A matching positive pattern after a negative match will include the branch again.

For example, a workflow with the following trigger will run when the workflow named `Build` runs on a branch that is named `releases/10` or `releases/beta/mona` but will not `releases/10-alpha`, `releases/beta/3-alpha`, or `main`.

```hljs yaml
on:
  workflow_run:
    workflows: ["Build"]
    types: [requested]
    branches:
      - 'releases/**'
      - '!releases/**-alpha'

```

## [`on.workflow_dispatch`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#onworkflow_dispatch)

When using the `workflow_dispatch` event, you can optionally specify inputs that are passed to the workflow.

This trigger only receives events when the workflow file is on the default branch.

## [`on.workflow_dispatch.inputs`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#onworkflow_dispatchinputs)

The triggered workflow receives the inputs in the `inputs` context. For more information, see [Contexts](https://docs.github.com/en/actions/learn-github-actions/contexts#inputs-context).

Note

- The workflow will also receive the inputs in the `github.event.inputs` context. The information in the `inputs` context and `github.event.inputs` context is identical except that the `inputs` context preserves Boolean values as Booleans instead of converting them to strings. The `choice` type resolves to a string and is a single selectable option.
- The maximum number of top-level properties for `inputs` is 10.
- The maximum payload for `inputs` is 65,535 characters.

### [Example of `on.workflow_dispatch.inputs`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-of-onworkflow_dispatchinputs)

```hljs yaml
on:
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: true
        default: 'warning'
        type: choice
        options:
          - info
          - warning
          - debug
        description: 'True to print to STDOUT'
        required: true
        type: boolean
      tags:
        description: 'Test scenario tags'
        required: true
        type: string
      environment:
        description: 'Environment to run tests against'
        type: environment
        required: true

jobs:
  print-tag:
    runs-on: ubuntu-latest
    steps:
      - name: Print the input tag to STDOUT
        run: echo  The tags are ${{ inputs.tags }}

```

## [`on.workflow_dispatch.inputs.<input_id>.required`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#onworkflow_dispatchinputsinput_idrequired)

A boolean specifying whether the input must be supplied.

## [`on.workflow_dispatch.inputs.<input_id>.type`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#onworkflow_dispatchinputsinput_idtype)

The value of this parameter is a string specifying the data type of the input. This must be one of: `boolean`, `choice`, `number`, `environment` or `string`.

## [`permissions`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#permissions)

You can use `permissions` to modify the default permissions granted to the `GITHUB_TOKEN`, adding or removing access as required, so that you only allow the minimum required access. For more information, see [Automatic token authentication](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token).

You can use `permissions` either as a top-level key, to apply to all jobs in the workflow, or within specific jobs. When you add the `permissions` key within a specific job, all actions and run commands within that job that use the `GITHUB_TOKEN` gain the access rights you specify. For more information, see [`jobs.<job_id>.permissions`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idpermissions).

For each of the available permissions, shown in the table below, you can assign one of the access levels: `read` (if applicable), `write`, or `none`. `write` includes `read`. If you specify the access for any of these permissions, all of those that are not specified are set to `none`.

Available permissions and details of what each allows an action to do:

| Permission | Allows an action using `GITHUB_TOKEN` to |
| --- | --- |
| `actions` | Work with GitHub Actions. For example, `actions: write` permits an action to cancel a workflow run. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-actions). |
| `attestations` | Work with artifact attestations. For example, `attestations: write` permits an action to generate an artifact attestation for a build. For more information, see [Using artifact attestations to establish provenance for builds](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds) |
| `checks` | Work with check runs and check suites. For example, `checks: write` permits an action to create a check run. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-checks). |
| `contents` | Work with the contents of the repository. For example, `contents: read` permits an action to list the commits, and `contents: write` allows the action to create a release. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-contents). |
| `deployments` | Work with deployments. For example, `deployments: write` permits an action to create a new deployment. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-deployments). |
| `discussions` | Work with GitHub Discussions. For example, `discussions: write` permits an action to close or delete a discussion. For more information, see [Using the GraphQL API for Discussions](https://docs.github.com/en/graphql/guides/using-the-graphql-api-for-discussions). |
| `id-token` | Fetch an OpenID Connect (OIDC) token. This requires `id-token: write`. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#updating-your-actions-for-oidc) |
| `issues` | Work with issues. For example, `issues: write` permits an action to add a comment to an issue. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-issues). |
| `models` | Generate AI inference responses with GitHub Models. For example, `models: read` permits an action to use the GitHub Models inference API. See [Prototyping with AI models](https://docs.github.com/en/github-models/prototyping-with-ai-models). |
| `packages` | Work with GitHub Packages. For example, `packages: write` permits an action to upload and publish packages on GitHub Packages. For more information, see [About permissions for GitHub Packages](https://docs.github.com/en/packages/learn-github-packages/about-permissions-for-github-packages#about-scopes-and-permissions-for-package-registries). |
| `pages` | Work with GitHub Pages. For example, `pages: write` permits an action to request a GitHub Pages build. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-pages). |
| `pull-requests` | Work with pull requests. For example, `pull-requests: write` permits an action to add a label to a pull request. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-pull-requests). |
| `security-events` | Work with GitHub code scanning and Dependabot alerts. For example, `security-events: read` permits an action to list the Dependabot alerts for the repository, and `security-events: write` allows an action to update the status of a code scanning alert. For more information, see [Repository permissions for 'Code scanning alerts'](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-code-scanning-alerts) and [Repository permissions for 'Dependabot alerts'](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-dependabot-alerts) in "Permissions required for GitHub Apps." |
| `statuses` | Work with commit statuses. For example, `statuses:read` permits an action to list the commit statuses for a given reference. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-commit-statuses). |

### [Defining access for the `GITHUB_TOKEN` scopes](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#defining-access-for-the-github_token-scopes)

You can define the access that the `GITHUB_TOKEN` will permit by specifying `read`, `write`, or `none` as the value of the available permissions within the `permissions` key.

```hljs yaml
permissions:
  actions: read|write|none
  attestations: read|write|none
  checks: read|write|none
  contents: read|write|none
  deployments: read|write|none
  id-token: write|none
  issues: read|write|none
  models: read|none
  discussions: read|write|none
  packages: read|write|none
  pages: read|write|none
  pull-requests: read|write|none
  security-events: read|write|none
  statuses: read|write|none

```

If you specify the access for any of these permissions, all of those that are not specified are set to `none`.

You can use the following syntax to define one of `read-all` or `write-all` access for all of the available permissions:

```hljs yaml
permissions: read-all

```

```hljs yaml
permissions: write-all

```

You can use the following syntax to disable permissions for all of the available permissions:

```hljs yaml
permissions: {}

```

#### [Changing the permissions in a forked repository](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#changing-the-permissions-in-a-forked-repository)

You can use the `permissions` key to add and remove read permissions for forked repositories, but typically you can't grant write access. The exception to this behavior is where an admin user has selected the **Send write tokens to workflows from pull requests** option in the GitHub Actions settings. For more information, see [Managing GitHub Actions settings for a repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#enabling-workflows-for-private-repository-forks).

### [Setting the `GITHUB_TOKEN` permissions for all jobs in a workflow](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#setting-the-github_token-permissions-for-all-jobs-in-a-workflow)

You can specify `permissions` at the top level of a workflow, so that the setting applies to all jobs in the workflow.

#### [Example: Setting the `GITHUB_TOKEN` permissions for an entire workflow](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-setting-the-github_token-permissions-for-an-entire-workflow)

This example shows permissions being set for the `GITHUB_TOKEN` that will apply to all jobs in the workflow. All permissions are granted read access.

```hljs yaml
name: "My workflow"

on: [ push ]

permissions: read-all

jobs:
  ...

```

## [`env`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#env)

A `map` of variables that are available to the steps of all jobs in the workflow. You can also set variables that are only available to the steps of a single job or to a single step. For more information, see [`jobs.<job_id>.env`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idenv) and [`jobs.<job_id>.steps[*].env`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstepsenv).

Variables in the `env` map cannot be defined in terms of other variables in the map.

When more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes.

### [Example of `env`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-of-env)

```hljs yaml
env:
  SERVER: production

```

## [`defaults`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#defaults)

Use `defaults` to create a `map` of default settings that will apply to all jobs in the workflow. You can also set default settings that are only available to a job. For more information, see [`jobs.<job_id>.defaults`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_iddefaults).

When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.

## [`defaults.run`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#defaultsrun)

You can use `defaults.run` to provide default `shell` and `working-directory` options for all [`run`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun) steps in a workflow. You can also set default settings for `run` that are only available to a job. For more information, see [`jobs.<job_id>.defaults.run`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_iddefaultsrun). You cannot use contexts or expressions in this keyword.

When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.

### [Example: Set the default shell and working directory](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-set-the-default-shell-and-working-directory)

```hljs yaml
defaults:
  run:
    shell: bash
    working-directory: ./scripts

```

## [`defaults.run.shell`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#defaultsrunshell)

Use `shell` to define the `shell` for a step. This keyword can reference several contexts. For more information, see [Contexts](https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability).

| Supported platform | `shell` parameter | Description | Command run internally |
| --- | --- | --- | --- |
| Linux / macOS | unspecified | The default shell on non-Windows platforms. Note that this runs a different command to when `bash` is specified explicitly. If `bash` is not found in the path, this is treated as `sh`. | `bash -e {0}` |
| All | `bash` | The default shell on non-Windows platforms with a fallback to `sh`. When specifying a bash shell on Windows, the bash shell included with Git for Windows is used. | `bash --noprofile --norc -eo pipefail {0}` |
| All | `pwsh` | The PowerShell Core. GitHub appends the extension `.ps1` to your script name. | `pwsh -command ". '{0}'"` |
| All | `python` | Executes the python command. | `python {0}` |
| Linux / macOS | `sh` | The fallback behavior for non-Windows platforms if no shell is provided and `bash` is not found in the path. | `sh -e {0}` |
| Windows | `cmd` | GitHub appends the extension `.cmd` to your script name and substitutes for `{0}`. | `%ComSpec% /D /E:ON /V:OFF /S /C "CALL "{0}""`. |
| Windows | `pwsh` | This is the default shell used on Windows. The PowerShell Core. GitHub appends the extension `.ps1` to your script name. If your self-hosted Windows runner does not have _PowerShell Core_ installed, then _PowerShell Desktop_ is used instead. | `pwsh -command ". '{0}'"`. |
| Windows | `powershell` | The PowerShell Desktop. GitHub appends the extension `.ps1` to your script name. | `powershell -command ". '{0}'"`. |

When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.

## [`defaults.run.working-directory`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#defaultsrunworking-directory)

Use `working-directory` to define the working directory for the `shell` for a step. This keyword can reference several contexts. For more information, see [Contexts](https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability).

Tip

Ensure the `working-directory` you assign exists on the runner before you run your shell in it.
When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.

## [`concurrency`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#concurrency)

Use `concurrency` to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can only use [`github`](https://docs.github.com/en/actions/learn-github-actions/contexts#github-context), [`inputs`](https://docs.github.com/en/actions/learn-github-actions/contexts#inputs-context) and [`vars`](https://docs.github.com/en/actions/learn-github-actions/contexts#vars-context) contexts. For more information about expressions, see [Evaluate expressions in workflows and actions](https://docs.github.com/en/actions/learn-github-actions/expressions).

You can also specify `concurrency` at the job level. For more information, see [`jobs.<job_id>.concurrency`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idconcurrency).

This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be `pending`. Any existing `pending` job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place.

To also cancel any currently running job or workflow in the same concurrency group, specify `cancel-in-progress: true`. To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify `cancel-in-progress` as an expression with any of the allowed expression contexts.

Note

- The concurrency group name is case insensitive. For example, `prod` and `Prod` will be treated as the same concurrency group.
- Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order.

### [Example: Using concurrency and the default behavior](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-concurrency-and-the-default-behavior)

The default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. The `concurrency` keyword allows you to control the concurrency of workflow runs.

For example, you can use the `concurrency` keyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch:

```hljs yaml
on:
  push:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

```

You can also limit the concurrency of jobs within a workflow by using the `concurrency` keyword at the job level:

```hljs yaml
on:
  push:
    branches:
      - main

jobs:
  job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: example-group
      cancel-in-progress: true

```

### [Example: Concurrency groups](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-concurrency-groups)

Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key.

The `concurrency` key is used to group workflows or jobs together into a concurrency group. When you define a `concurrency` key, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the same `concurrency` key, GitHub Actions will cancel any workflow or job already running with that key. The `concurrency` key can be a hard-coded string, or it can be a dynamic expression that includes context variables.

It is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group.

This means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary.

In this example, `job-1` is part of a concurrency group named `staging_environment`. This means that if a new run of `job-1` is triggered, any runs of the same job in the `staging_environment` concurrency group that are already in progress will be cancelled.

```hljs yaml
jobs:
  job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: staging_environment
      cancel-in-progress: true

```

Alternatively, using a dynamic expression such as `concurrency: ci-${{ github.ref }}` in your workflow means that the workflow or job would be part of a concurrency group named `ci-` followed by the reference of the branch or tag that triggered the workflow. In this example, if a new commit is pushed to the main branch while a previous run is still in progress, the previous run will be cancelled and the new one will start:

```hljs yaml
on:
  push:
    branches:
      - main

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

```

### [Example: Using concurrency to cancel any in-progress job or run](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-concurrency-to-cancel-any-in-progress-job-or-run)

To use concurrency to cancel any in-progress job or run in GitHub Actions, you can use the `concurrency` key with the `cancel-in-progress` option set to `true`:

```hljs yaml
concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true

```

Note that in this example, without defining a particular concurrency group, GitHub Actions will cancel _any_ in-progress run of the job or workflow.

### [Example: Using a fallback value](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-a-fallback-value)

If you build the group name with a property that is only defined for specific events, you can use a fallback value. For example, `github.head_ref` is only defined on `pull_request` events. If your workflow responds to other events in addition to `pull_request` events, you will need to provide a fallback to avoid a syntax error. The following concurrency group cancels in-progress jobs or runs on `pull_request` events only; if `github.head_ref` is undefined, the concurrency group will fallback to the run ID, which is guaranteed to be both unique and defined for the run.

```hljs yaml
concurrency:
  group: ${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

```

### [Example: Only cancel in-progress jobs or runs for the current workflow](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-only-cancel-in-progress-jobs-or-runs-for-the-current-workflow)

If you have multiple workflows in the same repository, concurrency group names must be unique across workflows to avoid canceling in-progress jobs or runs from other workflows. Otherwise, any previously in-progress or pending job will be canceled, regardless of the workflow.

To only cancel in-progress runs of the same workflow, you can use the `github.workflow` property to build the concurrency group:

```hljs yaml
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

```

### [Example: Only cancel in-progress jobs on specific branches](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-only-cancel-in-progress-jobs-on-specific-branches)

If you would like to cancel in-progress jobs on certain branches but not on others, you can use conditional expressions with `cancel-in-progress`. For example, you can do this if you would like to cancel in-progress jobs on development branches but not on release branches.

To only cancel in-progress runs of the same workflow when not running on a release branch, you can set `cancel-in-progress` to an expression similar to the following:

```hljs yaml
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ !contains(github.ref, 'release/')}}

```

In this example, multiple pushes to a `release/1.2.3` branch would not cancel in-progress runs. Pushes to another branch, such as `main`, would cancel in-progress runs.

## [`jobs`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobs)

A workflow run is made up of one or more `jobs`, which run in parallel by default. To run jobs sequentially, you can define dependencies on other jobs using the `jobs.<job_id>.needs` keyword.

Each job runs in a runner environment specified by `runs-on`.

You can run an unlimited number of jobs as long as you are within the workflow usage limits. For more information, see [Usage limits, billing, and administration](https://docs.github.com/en/actions/learn-github-actions/usage-limits-billing-and-administration) for GitHub-hosted runners and [Usage limits for self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/usage-limits-for-self-hosted-runners) for self-hosted runner usage limits.

If you need to find the unique identifier of a job running in a workflow run, you can use the GitHub API. For more information, see [REST API endpoints for GitHub Actions](https://docs.github.com/en/rest/actions#workflow-jobs).

## [`jobs.<job_id>`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_id)

Use `jobs.<job_id>` to give your job a unique identifier. The key `job_id` is a string and its value is a map of the job's configuration data. You must replace `<job_id>` with a string that is unique to the `jobs` object. The `<job_id>` must start with a letter or `_` and contain only alphanumeric characters, `-`, or `_`.

### [Example: Creating jobs](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-creating-jobs)

In this example, two jobs have been created, and their `job_id` values are `my_first_job` and `my_second_job`.

```hljs yaml
jobs:
  my_first_job:
    name: My first job
  my_second_job:
    name: My second job

```

## [`jobs.<job_id>.name`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idname)

Use `jobs.<job_id>.name` to set a name for the job, which is displayed in the GitHub UI.

## [`jobs.<job_id>.permissions`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idpermissions)

For a specific job, you can use `jobs.<job_id>.permissions` to modify the default permissions granted to the `GITHUB_TOKEN`, adding or removing access as required, so that you only allow the minimum required access. For more information, see [Automatic token authentication](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token).

By specifying the permission within a job definition, you can configure a different set of permissions for the `GITHUB_TOKEN` for each job, if required. Alternatively, you can specify the permissions for all jobs in the workflow. For information on defining permissions at the workflow level, see [`permissions`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#permissions).

For each of the available permissions, shown in the table below, you can assign one of the access levels: `read` (if applicable), `write`, or `none`. `write` includes `read`. If you specify the access for any of these permissions, all of those that are not specified are set to `none`.

Available permissions and details of what each allows an action to do:

| Permission | Allows an action using `GITHUB_TOKEN` to |
| --- | --- |
| `actions` | Work with GitHub Actions. For example, `actions: write` permits an action to cancel a workflow run. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-actions). |
| `attestations` | Work with artifact attestations. For example, `attestations: write` permits an action to generate an artifact attestation for a build. For more information, see [Using artifact attestations to establish provenance for builds](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds) |
| `checks` | Work with check runs and check suites. For example, `checks: write` permits an action to create a check run. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-checks). |
| `contents` | Work with the contents of the repository. For example, `contents: read` permits an action to list the commits, and `contents: write` allows the action to create a release. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-contents). |
| `deployments` | Work with deployments. For example, `deployments: write` permits an action to create a new deployment. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-deployments). |
| `discussions` | Work with GitHub Discussions. For example, `discussions: write` permits an action to close or delete a discussion. For more information, see [Using the GraphQL API for Discussions](https://docs.github.com/en/graphql/guides/using-the-graphql-api-for-discussions). |
| `id-token` | Fetch an OpenID Connect (OIDC) token. This requires `id-token: write`. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect#updating-your-actions-for-oidc) |
| `issues` | Work with issues. For example, `issues: write` permits an action to add a comment to an issue. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-issues). |
| `models` | Generate AI inference responses with GitHub Models. For example, `models: read` permits an action to use the GitHub Models inference API. See [Prototyping with AI models](https://docs.github.com/en/github-models/prototyping-with-ai-models). |
| `packages` | Work with GitHub Packages. For example, `packages: write` permits an action to upload and publish packages on GitHub Packages. For more information, see [About permissions for GitHub Packages](https://docs.github.com/en/packages/learn-github-packages/about-permissions-for-github-packages#about-scopes-and-permissions-for-package-registries). |
| `pages` | Work with GitHub Pages. For example, `pages: write` permits an action to request a GitHub Pages build. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-pages). |
| `pull-requests` | Work with pull requests. For example, `pull-requests: write` permits an action to add a label to a pull request. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-pull-requests). |
| `security-events` | Work with GitHub code scanning and Dependabot alerts. For example, `security-events: read` permits an action to list the Dependabot alerts for the repository, and `security-events: write` allows an action to update the status of a code scanning alert. For more information, see [Repository permissions for 'Code scanning alerts'](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-code-scanning-alerts) and [Repository permissions for 'Dependabot alerts'](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-dependabot-alerts) in "Permissions required for GitHub Apps." |
| `statuses` | Work with commit statuses. For example, `statuses:read` permits an action to list the commit statuses for a given reference. For more information, see [Permissions required for GitHub Apps](https://docs.github.com/en/rest/overview/permissions-required-for-github-apps?apiVersion=2022-11-28#repository-permissions-for-commit-statuses). |

### [Defining access for the `GITHUB_TOKEN` scopes](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#defining-access-for-the-github_token-scopes-1)

You can define the access that the `GITHUB_TOKEN` will permit by specifying `read`, `write`, or `none` as the value of the available permissions within the `permissions` key.

```hljs yaml
permissions:
  actions: read|write|none
  attestations: read|write|none
  checks: read|write|none
  contents: read|write|none
  deployments: read|write|none
  id-token: write|none
  issues: read|write|none
  models: read|none
  discussions: read|write|none
  packages: read|write|none
  pages: read|write|none
  pull-requests: read|write|none
  security-events: read|write|none
  statuses: read|write|none

```

If you specify the access for any of these permissions, all of those that are not specified are set to `none`.

You can use the following syntax to define one of `read-all` or `write-all` access for all of the available permissions:

```hljs yaml
permissions: read-all

```

```hljs yaml
permissions: write-all

```

You can use the following syntax to disable permissions for all of the available permissions:

```hljs yaml
permissions: {}

```

#### [Changing the permissions in a forked repository](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#changing-the-permissions-in-a-forked-repository-1)

You can use the `permissions` key to add and remove read permissions for forked repositories, but typically you can't grant write access. The exception to this behavior is where an admin user has selected the **Send write tokens to workflows from pull requests** option in the GitHub Actions settings. For more information, see [Managing GitHub Actions settings for a repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#enabling-workflows-for-private-repository-forks).

#### [Example: Setting the `GITHUB_TOKEN` permissions for one job in a workflow](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-setting-the-github_token-permissions-for-one-job-in-a-workflow)

This example shows permissions being set for the `GITHUB_TOKEN` that will only apply to the job named `stale`. Write access is granted for the `issues` and `pull-requests` permissions. All other permissions will have no access.

```hljs yaml
jobs:
  stale:
    runs-on: ubuntu-latest

    permissions:
      issues: write
      pull-requests: write

    steps:
      - uses: actions/stale@v9

```

## [`jobs.<job_id>.needs`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idneeds)

Use `jobs.<job_id>.needs` to identify any jobs that must complete successfully before this job will run. It can be a string or array of strings. If a job fails or is skipped, all jobs that need it are skipped unless the jobs use a conditional expression that causes the job to continue. If a run contains a series of jobs that need each other, a failure or skip applies to all jobs in the dependency chain from the point of failure or skip onwards. If you would like a job to run even if a job it is dependent on did not succeed, use the `always()` conditional expression in `jobs.<job_id>.if`.

### [Example: Requiring successful dependent jobs](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-requiring-successful-dependent-jobs)

```hljs yaml
jobs:
  job1:
  job2:
    needs: job1
  job3:
    needs: [job1, job2]

```

In this example, `job1` must complete successfully before `job2` begins, and `job3` waits for both `job1` and `job2` to complete.

The jobs in this example run sequentially:

1. `job1`
2. `job2`
3. `job3`

### [Example: Not requiring successful dependent jobs](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-not-requiring-successful-dependent-jobs)

```hljs yaml
jobs:
  job1:
  job2:
    needs: job1
  job3:
    if: ${{ always() }}
    needs: [job1, job2]

```

In this example, `job3` uses the `always()` conditional expression so that it always runs after `job1` and `job2` have completed, regardless of whether they were successful. For more information, see [Evaluate expressions in workflows and actions](https://docs.github.com/en/actions/learn-github-actions/expressions#status-check-functions).

## [`jobs.<job_id>.if`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idif)

You can use the `jobs.<job_id>.if` conditional to prevent a job from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see [Contexts reference](https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability).

Note

The `jobs.<job_id>.if` condition is evaluated before [`jobs.<job_id>.strategy.matrix`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstrategymatrix) is applied.

When you use expressions in an `if` conditional, you can, optionally, omit the `${{ }}` expression syntax because GitHub Actions automatically evaluates the `if` conditional as an expression. However, this exception does not apply everywhere.

You must always use the `${{ }}` expression syntax or escape with `''`, `""`, or `()` when the expression starts with `!`, since `!` is reserved notation in YAML format. For example:

```hljs yaml
if: ${{ ! startsWith(github.ref, 'refs/tags/') }}

```

For more information, see [Evaluate expressions in workflows and actions](https://docs.github.com/en/actions/learn-github-actions/expressions).

### [Example: Only run job for specific repository](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-only-run-job-for-specific-repository)

This example uses `if` to control when the `production-deploy` job can run. It will only run if the repository is named `octo-repo-prod` and is within the `octo-org` organization. Otherwise, the job will be marked as _skipped_.

```hljs yaml
name: example-workflow
on: [push]
jobs:
  production-deploy:
    if: github.repository == 'octo-org/octo-repo-prod'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats

```

## [`jobs.<job_id>.runs-on`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idruns-on)

Use `jobs.<job_id>.runs-on` to define the type of machine to run the job on.

- The destination machine can be either a [GitHub-hosted runner](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#choosing-github-hosted-runners), [larger runner](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#choosing-runners-in-a-group), or a [self-hosted runner](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#choosing-self-hosted-runners).

- You can target runners based on the labels assigned to them, or their group membership, or a combination of these.

- You can provide `runs-on` as:
  - A single string
  - A single variable containing a string
  - An array of strings, variables containing strings, or a combination of both
  - A `key: value` pair using the `group` or `labels` keys
- If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specified `runs-on` values. For example, here the job will only run on a self-hosted runner that has the labels `linux`, `x64`, and `gpu`:


```hljs yaml
runs-on: [self-hosted, linux, x64, gpu]

```


For more information, see [Choosing self-hosted runners](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#choosing-self-hosted-runners).

- You can mix strings and variables in an array. For example:


```hljs yaml
on:
    workflow_dispatch:
      inputs:
        chosen-os:
          required: true
          type: choice
          options:
        - Ubuntu
        - macOS

jobs:
test:
    runs-on: [self-hosted, "${{ inputs.chosen-os }}"]
    steps:
    - run: echo Hello world!

```

- If you would like to run your workflow on multiple machines, use [`jobs.<job_id>.strategy`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstrategy).


Note

Quotation marks are not required around simple strings like `self-hosted`, but they are required for expressions like `"${{ inputs.chosen-os }}"`.

### [Choosing GitHub-hosted runners](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#choosing-github-hosted-runners)

If you use a GitHub-hosted runner, each job runs in a fresh instance of a runner image specified by `runs-on`.

The value for runs-on, when you are using a GitHub-hosted runner, is a runner label or the name of a runner group. The labels for the standard GitHub-hosted runners are shown in the following tables.

For more information, see [About GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners).

### [Standard GitHub-hosted runners for public repositories](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#standard-github-hosted-runners-for-public-repositories)

For public repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. The use of these runners on public repositories is free and unlimited.

| **Virtual Machine** | **Processor (CPU)** | **Memory (RAM)** | **Storage (SSD)** | **Architecture** | **Workflow label** |
| --- | --- | --- | --- | --- | --- |
| Linux | 4 | 16 GB | 14 GB | x64 | `ubuntu-latest`,<br> `ubuntu-24.04`,<br> `ubuntu-22.04` |
| Windows | 4 | 16 GB | 14 GB | x64 | `windows-latest`,<br> `windows-2025`,<br> `windows-2022` |
| Linux \[Public preview\] | 4 | 16 GB | 14 GB | arm64 | `ubuntu-24.04-arm`,<br> `ubuntu-22.04-arm` |
| Windows \[Public preview\] | 4 | 16 GB | 14 GB | arm64 | `windows-11-arm` |
| macOS | 4 | 14 GB | 14 GB | Intel | `macos-13` |
| macOS | 3 (M1) | 7 GB | 14 GB | arm64 | `macos-latest`,<br> `macos-14`,<br> `macos-15` |

Note

The arm64 Linux and Windows runners are in public preview and subject to change.

### [Standard GitHub-hosted runners for private repositories](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#standard-github-hosted-runners-for--private-repositories)

For private repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. These runners use your GitHub account's allotment of free minutes, and are then charged at the per minute rates. For more information, see [About billing for GitHub Actions](https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions#per-minute-rates).

| **Virtual Machine** | **Processor (CPU)** | **Memory (RAM)** | **Storage (SSD)** | **Architecture** | **Workflow label** |
| --- | --- | --- | --- | --- | --- |
| Linux | 2 | 7 GB | 14 GB | x64 | `ubuntu-latest`,<br> `ubuntu-24.04`,<br> `ubuntu-22.04` |
| Windows | 2 | 7 GB | 14 GB | x64 | `windows-latest`,<br> `windows-2025`,<br> `windows-2022` |
| macOS | 4 | 14 GB | 14 GB | Intel | `macos-13` |
| macOS | 3 (M1) | 7 GB | 14 GB | arm64 | `macos-latest`,<br> `macos-14`,<br> `macos-15` |

In addition to the standard GitHub-hosted runners, GitHub offers customers on GitHub Team and GitHub Enterprise Cloud plans a range of managed virtual machines with advanced features - for example, more cores and disk space, GPU-powered machines, and ARM-powered machines. For more information, see [About larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-larger-runners/about-larger-runners).

Note

The `-latest` runner images are the latest stable images that GitHub provides, and might not be the most recent version of the operating system available from the operating system vendor.

Warning

Beta and Deprecated Images are provided "as-is", "with all faults" and "as available" and are excluded from the service level agreement and warranty. Beta Images may not be covered by customer support.

#### [Example: Specifying an operating system](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-specifying-an-operating-system)

```hljs yaml
runs-on: ubuntu-latest

```

For more information, see [About GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners).

### [Choosing self-hosted runners](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#choosing-self-hosted-runners)

To specify a self-hosted runner for your job, configure `runs-on` in your workflow file with self-hosted runner labels.

Self-hosted runners may have the `self-hosted` label. When setting up a self-hosted runner, by default we will include the label `self-hosted`. You may pass in the `--no-default-labels` flag to prevent the self-hosted label from being applied. Labels can be used to create targeting options for runners, such as operating system or architecture, we recommend providing an array of labels that begins with `self-hosted` (this must be listed first) and then includes additional labels as needed. When you specify an array of labels, jobs will be queued on runners that have all the labels that you specify.

Note that Actions Runner Controller does not support multiple labels and does not support the `self-hosted` label.

#### [Example: Using labels for runner selection](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-labels-for-runner-selection)

```hljs yaml
runs-on: [self-hosted, linux]

```

For more information, see [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners) and [Using self-hosted runners in a workflow](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow).

### [Choosing runners in a group](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#choosing-runners-in-a-group)

You can use `runs-on` to target runner groups, so that the job will execute on any runner that is a member of that group. For more granular control, you can also combine runner groups with labels.

Runner groups can only have [larger runners](https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/about-larger-runners) or [self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners) as members.

#### [Example: Using groups to control where jobs are run](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-groups-to-control-where-jobs-are-run)

In this example, Ubuntu runners have been added to a group called `ubuntu-runners`. The `runs-on` key sends the job to any available runner in the `ubuntu-runners` group:

```hljs yaml
name: learn-github-actions
on: [push]
jobs:
check-bats-version:
    runs-on:
      group: ubuntu-runners
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v

```

#### [Example: Combining groups and labels](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-combining-groups-and-labels)

When you combine groups and labels, the runner must meet both requirements to be eligible to run the job.

In this example, a runner group called `ubuntu-runners` is populated with Ubuntu runners, which have also been assigned the label `ubuntu-20.04-16core`. The `runs-on` key combines `group` and `labels` so that the job is routed to any available runner within the group that also has a matching label:

```hljs yaml
name: learn-github-actions
on: [push]
jobs:
check-bats-version:
    runs-on:
      group: ubuntu-runners
      labels: ubuntu-20.04-16core
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '14'
      - run: npm install -g bats
      - run: bats -v

```

## [`jobs.<job_id>.environment`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idenvironment)

Use `jobs.<job_id>.environment` to define the environment that the job references.

You can provide the environment as only the environment `name`, or as an environment object with the `name` and `url`. The URL maps to `environment_url` in the deployments API. For more information about the deployments API, see [REST API endpoints for repositories](https://docs.github.com/en/rest/repos#deployments).

Note

All deployment protection rules must pass before a job referencing the environment is sent to a runner. For more information, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment).

### [Example: Using a single environment name](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-a-single-environment-name)

```hljs yaml
environment: staging_environment

```

### [Example: Using environment name and URL](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-environment-name-and-url)

```hljs yaml
environment:
name: production_environment
url: https://github.com

```

The value of `url` can be an expression. Allowed expression contexts: [`github`](https://docs.github.com/en/actions/learn-github-actions/contexts#github-context), [`inputs`](https://docs.github.com/en/actions/learn-github-actions/contexts#inputs-context), [`vars`](https://docs.github.com/en/actions/learn-github-actions/contexts#vars-context), [`needs`](https://docs.github.com/en/actions/learn-github-actions/contexts#needs-context), [`strategy`](https://docs.github.com/en/actions/learn-github-actions/contexts#strategy-context), [`matrix`](https://docs.github.com/en/actions/learn-github-actions/contexts#matrix-context), [`job`](https://docs.github.com/en/actions/learn-github-actions/contexts#job-context), [`runner`](https://docs.github.com/en/actions/learn-github-actions/contexts#runner-context), [`env`](https://docs.github.com/en/actions/learn-github-actions/contexts#env-context), and [`steps`](https://docs.github.com/en/actions/learn-github-actions/contexts#steps-context). For more information about expressions, see [Evaluate expressions in workflows and actions](https://docs.github.com/en/actions/learn-github-actions/expressions).

### [Example: Using output as URL](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-output-as-url)

```hljs yaml
environment:
name: production_environment
url: ${{ steps.step_id.outputs.url_output }}

```

The value of `name` can be an expression. Allowed expression contexts: [`github`](https://docs.github.com/en/actions/learn-github-actions/contexts#github-context), [`inputs`](https://docs.github.com/en/actions/learn-github-actions/contexts#inputs-context), [`vars`](https://docs.github.com/en/actions/learn-github-actions/contexts#vars-context), [`needs`](https://docs.github.com/en/actions/learn-github-actions/contexts#needs-context), [`strategy`](https://docs.github.com/en/actions/learn-github-actions/contexts#strategy-context), and [`matrix`](https://docs.github.com/en/actions/learn-github-actions/contexts#matrix-context). For more information about expressions, see [Evaluate expressions in workflows and actions](https://docs.github.com/en/actions/learn-github-actions/expressions).

### [Example: Using an expression as environment name](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-an-expression-as-environment-name)

```hljs yaml
environment:
name: ${{ github.ref_name }}

```

## [`jobs.<job_id>.concurrency`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idconcurrency)

You can use `jobs.<job_id>.concurrency` to ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts: [`github`](https://docs.github.com/en/actions/learn-github-actions/contexts#github-context), [`inputs`](https://docs.github.com/en/actions/learn-github-actions/contexts#inputs-context), [`vars`](https://docs.github.com/en/actions/learn-github-actions/contexts#vars-context), [`needs`](https://docs.github.com/en/actions/learn-github-actions/contexts#needs-context), [`strategy`](https://docs.github.com/en/actions/learn-github-actions/contexts#strategy-context), and [`matrix`](https://docs.github.com/en/actions/learn-github-actions/contexts#matrix-context). For more information about expressions, see [Evaluate expressions in workflows and actions](https://docs.github.com/en/actions/learn-github-actions/expressions).

You can also specify `concurrency` at the workflow level. For more information, see [`concurrency`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#concurrency).

This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be `pending`. Any existing `pending` job or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place.

To also cancel any currently running job or workflow in the same concurrency group, specify `cancel-in-progress: true`. To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specify `cancel-in-progress` as an expression with any of the allowed expression contexts.

Note

- The concurrency group name is case insensitive. For example, `prod` and `Prod` will be treated as the same concurrency group.
- Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order.

### [Example: Using concurrency and the default behavior](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-concurrency-and-the-default-behavior-1)

The default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. The `concurrency` keyword allows you to control the concurrency of workflow runs.

For example, you can use the `concurrency` keyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch:

```hljs yaml
on:
push:
    branches:
      - main

concurrency:
group: ${{ github.workflow }}-${{ github.ref }}
cancel-in-progress: true

```

You can also limit the concurrency of jobs within a workflow by using the `concurrency` keyword at the job level:

```hljs yaml
on:
push:
    branches:
      - main

jobs:
job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: example-group
      cancel-in-progress: true

```

### [Example: Concurrency groups](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-concurrency-groups-1)

Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key.

The `concurrency` key is used to group workflows or jobs together into a concurrency group. When you define a `concurrency` key, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the same `concurrency` key, GitHub Actions will cancel any workflow or job already running with that key. The `concurrency` key can be a hard-coded string, or it can be a dynamic expression that includes context variables.

It is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group.

This means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary.

In this example, `job-1` is part of a concurrency group named `staging_environment`. This means that if a new run of `job-1` is triggered, any runs of the same job in the `staging_environment` concurrency group that are already in progress will be cancelled.

```hljs yaml
jobs:
job-1:
    runs-on: ubuntu-latest
    concurrency:
      group: staging_environment
      cancel-in-progress: true

```

Alternatively, using a dynamic expression such as `concurrency: ci-${{ github.ref }}` in your workflow means that the workflow or job would be part of a concurrency group named `ci-` followed by the reference of the branch or tag that triggered the workflow. In this example, if a new commit is pushed to the main branch while a previous run is still in progress, the previous run will be cancelled and the new one will start:

```hljs yaml
on:
push:
    branches:
      - main

concurrency:
group: ci-${{ github.ref }}
cancel-in-progress: true

```

### [Example: Using concurrency to cancel any in-progress job or run](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-concurrency-to-cancel-any-in-progress-job-or-run-1)

To use concurrency to cancel any in-progress job or run in GitHub Actions, you can use the `concurrency` key with the `cancel-in-progress` option set to `true`:

```hljs yaml
concurrency:
group: ${{ github.ref }}
cancel-in-progress: true

```

Note that in this example, without defining a particular concurrency group, GitHub Actions will cancel _any_ in-progress run of the job or workflow.

### [Example: Using a fallback value](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-a-fallback-value-1)

If you build the group name with a property that is only defined for specific events, you can use a fallback value. For example, `github.head_ref` is only defined on `pull_request` events. If your workflow responds to other events in addition to `pull_request` events, you will need to provide a fallback to avoid a syntax error. The following concurrency group cancels in-progress jobs or runs on `pull_request` events only; if `github.head_ref` is undefined, the concurrency group will fallback to the run ID, which is guaranteed to be both unique and defined for the run.

```hljs yaml
concurrency:
group: ${{ github.head_ref || github.run_id }}
cancel-in-progress: true

```

### [Example: Only cancel in-progress jobs or runs for the current workflow](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-only-cancel-in-progress-jobs-or-runs-for-the-current-workflow-1)

If you have multiple workflows in the same repository, concurrency group names must be unique across workflows to avoid canceling in-progress jobs or runs from other workflows. Otherwise, any previously in-progress or pending job will be canceled, regardless of the workflow.

To only cancel in-progress runs of the same workflow, you can use the `github.workflow` property to build the concurrency group:

```hljs yaml
concurrency:
group: ${{ github.workflow }}-${{ github.ref }}
cancel-in-progress: true

```

### [Example: Only cancel in-progress jobs on specific branches](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-only-cancel-in-progress-jobs-on-specific-branches-1)

If you would like to cancel in-progress jobs on certain branches but not on others, you can use conditional expressions with `cancel-in-progress`. For example, you can do this if you would like to cancel in-progress jobs on development branches but not on release branches.

To only cancel in-progress runs of the same workflow when not running on a release branch, you can set `cancel-in-progress` to an expression similar to the following:

```hljs yaml
concurrency:
group: ${{ github.workflow }}-${{ github.ref }}
cancel-in-progress: ${{ !contains(github.ref, 'release/')}}

```

In this example, multiple pushes to a `release/1.2.3` branch would not cancel in-progress runs. Pushes to another branch, such as `main`, would cancel in-progress runs.

## [`jobs.<job_id>.outputs`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idoutputs)

You can use `jobs.<job_id>.outputs` to create a `map` of outputs for a job. Job outputs are available to all downstream jobs that depend on this job. For more information on defining job dependencies, see [`jobs.<job_id>.needs`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idneeds).

Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding.

Job outputs containing expressions are evaluated on the runner at the end of each job. Outputs containing secrets are redacted on the runner and not sent to GitHub Actions.

If an output is skipped because it may contain a secret, you will see the following warning message: "Skip output `{output.Key}` since it may contain secret." For more information on how to handle secrets, please refer to the [Example: Masking and passing a secret between jobs or workflows](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions#example-masking-and-passing-a-secret-between-jobs-or-workflows).

To use job outputs in a dependent job, you can use the `needs` context. For more information, see [Contexts reference](https://docs.github.com/en/actions/learn-github-actions/contexts#needs-context).

### [Example: Defining outputs for a job](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-defining-outputs-for-a-job)

```hljs yaml
jobs:
job1:
    runs-on: ubuntu-latest
    # Map a step output to a job output
    outputs:
      output1: ${{ steps.step1.outputs.test }}
      output2: ${{ steps.step2.outputs.test }}
    steps:
      - id: step1
        run: echo "test=hello" >> "$GITHUB_OUTPUT"
      - id: step2
        run: echo "test=world" >> "$GITHUB_OUTPUT"
job2:
    runs-on: ubuntu-latest
    needs: job1
    steps:
      - env:
          OUTPUT1: ${{needs.job1.outputs.output1}}
          OUTPUT2: ${{needs.job1.outputs.output2}}
        run: echo "$OUTPUT1 $OUTPUT2"

```

### [Using Job Outputs in a Matrix Job](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#using-job-outputs-in-a-matrix-job)

Matrices can be used to generate multiple outputs of different names. When using a matrix, job outputs will be combined from all jobs inside the matrix.

```hljs yaml
jobs:
job1:
    runs-on: ubuntu-latest
    outputs:
      output_1: ${{ steps.gen_output.outputs.output_1 }}
      output_2: ${{ steps.gen_output.outputs.output_2 }}
      output_3: ${{ steps.gen_output.outputs.output_3 }}
    strategy:
      matrix:
        version: [1, 2, 3]
    steps:
      - name: Generate output
        id: gen_output
        run: |
          version="${{ matrix.version }}"
          echo "output_${version}=${version}" >> "$GITHUB_OUTPUT"
job2:
    runs-on: ubuntu-latest
    needs: [job1]
    steps:
      # Will show
      # {
      #   "output_1": "1",
      #   "output_2": "2",
      #   "output_3": "3"
      # }
      - run: echo '${{ toJSON(needs.job1.outputs) }}'

```

Warning

Actions does not guarantee the order that matrix jobs will run in. Ensure that the output name is unique, otherwise the last matrix job that runs will override the output value.

## [`jobs.<job_id>.env`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idenv)

A `map` of variables that are available to all steps in the job. You can set variables for the entire workflow or an individual step. For more information, see [`env`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#env) and [`jobs.<job_id>.steps[*].env`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstepsenv).

When more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes.

### [Example of `jobs.<job_id>.env`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-of-jobsjob_idenv)

```hljs yaml
jobs:
job1:
    env:
      FIRST_NAME: Mona

```

## [`jobs.<job_id>.defaults`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_iddefaults)

Use `jobs.<job_id>.defaults` to create a `map` of default settings that will apply to all steps in the job. You can also set default settings for the entire workflow. For more information, see [`defaults`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#defaults).

When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.

## [`jobs.<job_id>.defaults.run`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_iddefaultsrun)

Use `jobs.<job_id>.defaults.run` to provide default `shell` and `working-directory` to all `run` steps in the job.

You can provide default `shell` and `working-directory` options for all [`run`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsrun) steps in a job. You can also set default settings for `run` for the entire workflow. For more information, see [`defaults.run`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#defaultsrun).

These can be overridden at the `jobs.<job_id>.defaults.run` and `jobs.<job_id>.steps[*].run` levels.

When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.

## [`jobs.<job_id>.defaults.run.shell`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_iddefaultsrunshell)

Use `shell` to define the `shell` for a step. This keyword can reference several contexts. For more information, see [Contexts](https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability).

| Supported platform | `shell` parameter | Description | Command run internally |
| --- | --- | --- | --- |
| Linux / macOS | unspecified | The default shell on non-Windows platforms. Note that this runs a different command to when `bash` is specified explicitly. If `bash` is not found in the path, this is treated as `sh`. | `bash -e {0}` |
| All | `bash` | The default shell on non-Windows platforms with a fallback to `sh`. When specifying a bash shell on Windows, the bash shell included with Git for Windows is used. | `bash --noprofile --norc -eo pipefail {0}` |
| All | `pwsh` | The PowerShell Core. GitHub appends the extension `.ps1` to your script name. | `pwsh -command ". '{0}'"` |
| All | `python` | Executes the python command. | `python {0}` |
| Linux / macOS | `sh` | The fallback behavior for non-Windows platforms if no shell is provided and `bash` is not found in the path. | `sh -e {0}` |
| Windows | `cmd` | GitHub appends the extension `.cmd` to your script name and substitutes for `{0}`. | `%ComSpec% /D /E:ON /V:OFF /S /C "CALL "{0}""`. |
| Windows | `pwsh` | This is the default shell used on Windows. The PowerShell Core. GitHub appends the extension `.ps1` to your script name. If your self-hosted Windows runner does not have _PowerShell Core_ installed, then _PowerShell Desktop_ is used instead. | `pwsh -command ". '{0}'"`. |
| Windows | `powershell` | The PowerShell Desktop. GitHub appends the extension `.ps1` to your script name. | `powershell -command ". '{0}'"`. |

When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.

## [`jobs.<job_id>.defaults.run.working-directory`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_iddefaultsrunworking-directory)

Use `working-directory` to define the working directory for the `shell` for a step. This keyword can reference several contexts. For more information, see [Contexts](https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability).

Tip

Ensure the `working-directory` you assign exists on the runner before you run your shell in it.
When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow.

### [Example: Setting default `run` step options for a job](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-setting-default-run-step-options-for-a-job)

```hljs yaml
jobs:
job1:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: ./scripts

```

## [`jobs.<job_id>.steps`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idsteps)

A job contains a sequence of tasks called `steps`. Steps can run commands, run setup tasks, or run an action in your repository, a public repository, or an action published in a Docker registry. Not all steps run actions, but all actions run as a step. Each step runs in its own process in the runner environment and has access to the workspace and filesystem. Because steps run in their own process, changes to environment variables are not preserved between steps. GitHub provides built-in steps to set up and complete a job.

GitHub only displays the first 1,000 checks, however, you can run an unlimited number of steps as long as you are within the workflow usage limits. For more information, see [Usage limits, billing, and administration](https://docs.github.com/en/actions/learn-github-actions/usage-limits-billing-and-administration) for GitHub-hosted runners and [Usage limits for self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/usage-limits-for-self-hosted-runners) for self-hosted runner usage limits.

### [Example of `jobs.<job_id>.steps`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-of-jobsjob_idsteps)

```hljs yaml
name: Greeting from Mona

on: push

jobs:
my-job:
    name: My Job
    runs-on: ubuntu-latest
    steps:
      - name: Print a greeting
        env:
          MY_VAR: Hi there! My name is
          FIRST_NAME: Mona
          MIDDLE_NAME: The
          LAST_NAME: Octocat
        run: |
          echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME.

```

## [`jobs.<job_id>.steps[*].id`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idstepsid)

A unique identifier for the step. You can use the `id` to reference the step in contexts. For more information, see [Contexts reference](https://docs.github.com/en/actions/learn-github-actions/contexts).

## [`jobs.<job_id>.steps[*].if`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idstepsif)

You can use the `if` conditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, see [Contexts reference](https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability).

When you use expressions in an `if` conditional, you can, optionally, omit the `${{ }}` expression syntax because GitHub Actions automatically evaluates the `if` conditional as an expression. However, this exception does not apply everywhere.

You must always use the `${{ }}` expression syntax or escape with `''`, `""`, or `()` when the expression starts with `!`, since `!` is reserved notation in YAML format. For example:

```hljs yaml
if: ${{ ! startsWith(github.ref, 'refs/tags/') }}

```

For more information, see [Evaluate expressions in workflows and actions](https://docs.github.com/en/actions/learn-github-actions/expressions).

### [Example: Using contexts](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-contexts)

This step only runs when the event type is a `pull_request` and the event action is `unassigned`.

```hljs yaml
steps:
  - name: My first step
    if: ${{ github.event_name == 'pull_request' && github.event.action == 'unassigned' }}
    run: echo This event is a pull request that had an assignee removed.

```

### [Example: Using status check functions](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-status-check-functions)

The `my backup step` only runs when the previous step of a job fails. For more information, see [Evaluate expressions in workflows and actions](https://docs.github.com/en/actions/learn-github-actions/expressions#status-check-functions).

```hljs yaml
steps:
  - name: My first step
    uses: octo-org/action-name@main
  - name: My backup step
    if: ${{ failure() }}
    uses: actions/heroku@1.0.0

```

### [Example: Using secrets](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-secrets)

Secrets cannot be directly referenced in `if:` conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job.

If a secret has not been set, the return value of an expression referencing the secret (such as `${{ secrets.SuperSecret }}` in the example) will be an empty string.

```hljs yaml
name: Run a step if a secret has been set
on: push
jobs:
my-jobname:
    runs-on: ubuntu-latest
    env:
      super_secret: ${{ secrets.SuperSecret }}
    steps:
      - if: ${{ env.super_secret != '' }}
        run: echo 'This step will only run if the secret has a value set.'
      - if: ${{ env.super_secret == '' }}
        run: echo 'This step will only run if the secret does not have a value set.'

```

For more information, see [Contexts reference](https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability) and [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions).

## [`jobs.<job_id>.steps[*].name`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idstepsname)

A name for your step to display on GitHub.

## [`jobs.<job_id>.steps[*].uses`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idstepsuses)

Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in a [published Docker container image](https://hub.docker.com/).

We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update.

- Using the commit SHA of a released action version is the safest for stability and security.
- If the action publishes major version tags, you should expect to receive critical fixes and security patches while still retaining compatibility. Note that this behavior is at the discretion of the action's author.
- Using the default branch of an action may be convenient, but if someone releases a new major version with a breaking change, your workflow could break.

Some actions require inputs that you must set using the [`with`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstepswith) keyword. Review the action's README file to determine the inputs required.

Actions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux environment. For more details, see [`runs-on`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on).

### [Example: Using versioned actions](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-versioned-actions)

```hljs yaml
steps:
# Reference a specific commit
  - uses: actions/checkout@8f4b7f84864484a7bf31766abe9204da3cbe65b3
# Reference the major version of a release
  - uses: actions/checkout@v4
# Reference a specific version
  - uses: actions/checkout@v4.2.0
# Reference a branch
  - uses: actions/checkout@main

```

### [Example: Using a public action](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-a-public-action)

`{owner}/{repo}@{ref}`

You can specify a branch, ref, or SHA in a public GitHub repository.

```hljs yaml
jobs:
my_first_job:
    steps:
      - name: My first step
        # Uses the default branch of a public repository
        uses: actions/heroku@main
      - name: My second step
        # Uses a specific version tag of a public repository
        uses: actions/aws@v2.0.1

```

### [Example: Using a public action in a subdirectory](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-a-public-action-in-a-subdirectory)

`{owner}/{repo}/{path}@{ref}`

A subdirectory in a public GitHub repository at a specific branch, ref, or SHA.

```hljs yaml
jobs:
my_first_job:
    steps:
      - name: My first step
        uses: actions/aws/ec2@main

```

### [Example: Using an action in the same repository as the workflow](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-an-action-in-the-same-repository-as-the-workflow)

`./path/to/dir`

The path to the directory that contains the action in your workflow's repository. You must check out your repository before using the action.

Example repository file structure:

```hljs shell
|-- hello-world (repository)
|   |__ .github
|        workflows
|            my-first-workflow.yml
|        actions
|           |__ hello-world-action
|                action.yml

```

The path is relative ( `./`) to the default working directory ( `github.workspace`, `$GITHUB_WORKSPACE`). If the action checks out the repository to a location different than the workflow, the relative path used for local actions must be updated.

Example workflow file:

```hljs yaml
jobs:
my_first_job:
    runs-on: ubuntu-latest
    steps:
      # This step checks out a copy of your repository.
      - name: My first step - check out repository
        uses: actions/checkout@v4
      # This step references the directory that contains the action.
      - name: Use local hello-world-action
        uses: ./.github/actions/hello-world-action

```

### [Example: Using a Docker Hub action](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-a-docker-hub-action)

`docker://{image}:{tag}`

A Docker image published on [Docker Hub](https://hub.docker.com/).

```hljs yaml
jobs:
my_first_job:
    steps:
      - name: My first step
        uses: docker://alpine:3.8

```

### [Example: Using the GitHub Packages Container registry](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-the-github-packages-container-registry)

`docker://{host}/{image}:{tag}`

A public Docker image in the GitHub Packages Container registry.

```hljs yaml
jobs:
my_first_job:
    steps:
      - name: My first step
        uses: docker://ghcr.io/OWNER/IMAGE_NAME

```

### [Example: Using a Docker public registry action](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-a-docker-public-registry-action)

`docker://{host}/{image}:{tag}`

A Docker image in a public registry. This example uses the Google Container Registry at `gcr.io`.

```hljs yaml
jobs:
my_first_job:
    steps:
      - name: My first step
        uses: docker://gcr.io/cloud-builders/gradle

```

### [Example: Using an action inside a different private repository than the workflow](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-an-action-inside-a-different-private-repository-than-the-workflow)

Your workflow must checkout the private repository and reference the action locally. Generate a personal access token and add the token as a secret. For more information, see [Managing your personal access tokens](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token) and [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions).

Replace `PERSONAL_ACCESS_TOKEN` in the example with the name of your secret.

```hljs yaml
jobs:
my_first_job:
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          repository: octocat/my-private-repo
          ref: v1.0
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          path: ./.github/actions/my-private-repo
      - name: Run my action
        uses: ./.github/actions/my-private-repo/my-action

```

Alternatively, use a GitHub App instead of a personal access token in order to ensure your workflow continues to run even if the personal access token owner leaves. For more information, see [Making authenticated API requests with a GitHub App in a GitHub Actions workflow](https://docs.github.com/en/apps/creating-github-apps/guides/making-authenticated-api-requests-with-a-github-app-in-a-github-actions-workflow).

## [`jobs.<job_id>.steps[*].run`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idstepsrun)

Runs command-line programs that do not exceed 21,000 characters using the operating system's shell. If you do not provide a `name`, the step name will default to the text specified in the `run` command.

Commands run using non-login shells by default. You can choose a different shell and customize the shell used to run commands. For more information, see [`jobs.<job_id>.steps[*].shell`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstepsshell).

Each `run` keyword represents a new process and shell in the runner environment. When you provide multi-line commands, each line runs in the same shell. For example:

- A single-line command:


```hljs yaml
- name: Install Dependencies
run: npm install

```

- A multi-line command:


```hljs yaml
- name: Clean install dependencies and build
run: |
    npm ci
    npm run build

```

## [`jobs.<job_id>.steps[*].working-directory`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idstepsworking-directory)

Using the `working-directory` keyword, you can specify the working directory of where to run the command.

```hljs yaml
- name: Clean temp directory
run: rm -rf *
working-directory: ./temp

```

Alternatively, you can specify a default working directory for all `run` steps in a job, or for all `run` steps in the entire workflow. For more information, see [`defaults.run.working-directory`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#defaultsrunworking-directory) and [`jobs.<job_id>.defaults.run.working-directory`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_iddefaultsrunworking-directory).

You can also use a `run` step to run a script. For more information, see [Adding scripts to your workflow](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/adding-scripts-to-your-workflow).

## [`jobs.<job_id>.steps[*].shell`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idstepsshell)

You can override the default shell settings in the runner's operating system and the job's default using the `shell` keyword. You can use built-in `shell` keywords, or you can define a custom set of shell options. The shell command that is run internally executes a temporary file that contains the commands specified in the `run` keyword.

| Supported platform | `shell` parameter | Description | Command run internally |
| --- | --- | --- | --- |
| Linux / macOS | unspecified | The default shell on non-Windows platforms. Note that this runs a different command to when `bash` is specified explicitly. If `bash` is not found in the path, this is treated as `sh`. | `bash -e {0}` |
| All | `bash` | The default shell on non-Windows platforms with a fallback to `sh`. When specifying a bash shell on Windows, the bash shell included with Git for Windows is used. | `bash --noprofile --norc -eo pipefail {0}` |
| All | `pwsh` | The PowerShell Core. GitHub appends the extension `.ps1` to your script name. | `pwsh -command ". '{0}'"` |
| All | `python` | Executes the python command. | `python {0}` |
| Linux / macOS | `sh` | The fallback behavior for non-Windows platforms if no shell is provided and `bash` is not found in the path. | `sh -e {0}` |
| Windows | `cmd` | GitHub appends the extension `.cmd` to your script name and substitutes for `{0}`. | `%ComSpec% /D /E:ON /V:OFF /S /C "CALL "{0}""`. |
| Windows | `pwsh` | This is the default shell used on Windows. The PowerShell Core. GitHub appends the extension `.ps1` to your script name. If your self-hosted Windows runner does not have _PowerShell Core_ installed, then _PowerShell Desktop_ is used instead. | `pwsh -command ". '{0}'"`. |
| Windows | `powershell` | The PowerShell Desktop. GitHub appends the extension `.ps1` to your script name. | `powershell -command ". '{0}'"`. |

Alternatively, you can specify a default shell for all `run` steps in a job, or for all `run` steps in the entire workflow. For more information, see [`defaults.run.shell`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#defaultsrunshell) and [`jobs.<job_id>.defaults.run.shell`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_iddefaultsrunshell).

### [Example: Running a command using Bash](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-running-a-command-using-bash)

```hljs yaml
steps:
  - name: Display the path
    shell: bash
    run: echo $PATH

```

### [Example: Running a command using Windows `cmd`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-running-a-command-using-windows-cmd)

```hljs yaml
steps:
  - name: Display the path
    shell: cmd
    run: echo %PATH%

```

### [Example: Running a command using PowerShell Core](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-running-a-command-using-powershell-core)

```hljs yaml
steps:
  - name: Display the path
    shell: pwsh
    run: echo ${env:PATH}

```

### [Example: Using PowerShell Desktop to run a command](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-powershell-desktop-to-run-a-command)

```hljs yaml
steps:
  - name: Display the path
    shell: powershell
    run: echo ${env:PATH}

```

### [Example: Running an inline Python script](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-running-an-inline-python-script)

```hljs yaml
steps:
  - name: Display the path
    shell: python
    run: |
      import os
      print(os.environ['PATH'])

```

### [Custom shell](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#custom-shell)

You can set the `shell` value to a template string using `command [options] {0} [more_options]`. GitHub interprets the first whitespace-delimited word of the string as the command, and inserts the file name for the temporary script at `{0}`.

For example:

```hljs yaml
steps:
  - name: Display the environment variables and their values
    shell: perl {0}
    run: |
      print %ENV

```

The command used, `perl` in this example, must be installed on the runner.

For information about the software included on GitHub-hosted runners, see [About GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-software).

### [Exit codes and error action preference](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#exit-codes-and-error-action-preference)

For built-in shell keywords, we provide the following defaults that are executed by GitHub-hosted runners. You should use these guidelines when running shell scripts.

- `bash`/ `sh`:
  - By default, fail-fast behavior is enforced using `set -e` for both `sh` and `bash`. When `shell: bash` is specified, `-o pipefail` is also applied to enforce early exit from pipelines that generate a non-zero exit status.
  - You can take full control over shell parameters by providing a template string to the shell options. For example, `bash {0}`.
  - `sh`-like shells exit with the exit code of the last command executed in a script, which is also the default behavior for actions. The runner will report the status of the step as fail/succeed based on this exit code.
- `powershell`/ `pwsh`
  - Fail-fast behavior when possible. For `pwsh` and `powershell` built-in shell, we will prepend `$ErrorActionPreference = 'stop'` to script contents.
  - We append `if ((Test-Path -LiteralPath variable:\LASTEXITCODE)) { exit $LASTEXITCODE }` to powershell scripts so action statuses reflect the script's last exit code.
  - Users can always opt out by not using the built-in shell, and providing a custom shell option like: `pwsh -File {0}`, or `powershell -Command "& '{0}'"`, depending on need.
- `cmd`
  - There doesn't seem to be a way to fully opt into fail-fast behavior other than writing your script to check each error code and respond accordingly. Because we can't actually provide that behavior by default, you need to write this behavior into your script.
  - `cmd.exe` will exit with the error level of the last program it executed, and it will return the error code to the runner. This behavior is internally consistent with the previous `sh` and `pwsh` default behavior and is the `cmd.exe` default, so this behavior remains intact.

## [`jobs.<job_id>.steps[*].with`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idstepswith)

A `map` of the input parameters defined by the action. Each input parameter is a key/value pair. Input parameters are set as environment variables. The variable is prefixed with `INPUT_` and converted to upper case.

Input parameters defined for a Docker container must use `args`. For more information, see [`jobs.<job_id>.steps[*].with.args`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstepswithargs).

### [Example of `jobs.<job_id>.steps[*].with`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-of-jobsjob_idstepswith)

Defines the three input parameters ( `first_name`, `middle_name`, and `last_name`) defined by the `hello_world` action. These input variables will be accessible to the `hello-world` action as `INPUT_FIRST_NAME`, `INPUT_MIDDLE_NAME`, and `INPUT_LAST_NAME` environment variables.

```hljs yaml
jobs:
my_first_job:
    steps:
      - name: My first step
        uses: actions/hello_world@main
        with:
          first_name: Mona
          middle_name: The
          last_name: Octocat

```

## [`jobs.<job_id>.steps[*].with.args`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idstepswithargs)

A `string` that defines the inputs for a Docker container. GitHub passes the `args` to the container's `ENTRYPOINT` when the container starts up. An `array of strings` is not supported by this parameter. A single argument that includes spaces should be surrounded by double quotes `""`.

### [Example of `jobs.<job_id>.steps[*].with.args`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-of-jobsjob_idstepswithargs)

```hljs yaml
steps:
  - name: Explain why this job ran
    uses: octo-org/action-name@main
    with:
      entrypoint: /bin/echo
      args: The ${{ github.event_name }} event triggered this step.

```

The `args` are used in place of the `CMD` instruction in a `Dockerfile`. If you use `CMD` in your `Dockerfile`, use the guidelines ordered by preference:

1. Document required arguments in the action's README and omit them from the `CMD` instruction.
2. Use defaults that allow using the action without specifying any `args`.
3. If the action exposes a `--help` flag, or something similar, use that as the default to make your action self-documenting.

## [`jobs.<job_id>.steps[*].with.entrypoint`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idstepswithentrypoint)

Overrides the Docker `ENTRYPOINT` in the `Dockerfile`, or sets it if one wasn't already specified. Unlike the Docker `ENTRYPOINT` instruction which has a shell and exec form, `entrypoint` keyword accepts only a single string defining the executable to be run.

### [Example of `jobs.<job_id>.steps[*].with.entrypoint`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-of-jobsjob_idstepswithentrypoint)

```hljs yaml
steps:
  - name: Run a custom command
    uses: octo-org/action-name@main
    with:
      entrypoint: /a/different/executable

```

The `entrypoint` keyword is meant to be used with Docker container actions, but you can also use it with JavaScript actions that don't define any inputs.

## [`jobs.<job_id>.steps[*].env`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idstepsenv)

Sets variables for steps to use in the runner environment. You can also set variables for the entire workflow or a job. For more information, see [`env`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#env) and [`jobs.<job_id>.env`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idenv).

When more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes.

Public actions may specify expected variables in the README file. If you are setting a secret or sensitive value, such as a password or token, you must set secrets using the `secrets` context. For more information, see [Contexts reference](https://docs.github.com/en/actions/learn-github-actions/contexts).

### [Example of `jobs.<job_id>.steps[*].env`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-of-jobsjob_idstepsenv)

```hljs yaml
steps:
  - name: My first action
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      FIRST_NAME: Mona
      LAST_NAME: Octocat

```

## [`jobs.<job_id>.steps[*].continue-on-error`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idstepscontinue-on-error)

Prevents a job from failing when a step fails. Set to `true` to allow a job to pass when this step fails.

## [`jobs.<job_id>.steps[*].timeout-minutes`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idstepstimeout-minutes)

The maximum number of minutes to run the step before killing the process.

Fractional values are not supported. `timeout-minutes` must be a positive integer.

## [`jobs.<job_id>.timeout-minutes`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idtimeout-minutes)

The maximum number of minutes to let a job run before GitHub automatically cancels it. Default: 360

If the timeout exceeds the job execution time limit for the runner, the job will be canceled when the execution time limit is met instead. For more information about job execution time limits, see [Usage limits, billing, and administration](https://docs.github.com/en/actions/learn-github-actions/usage-limits-billing-and-administration#usage-limits) for GitHub-hosted runners and [Usage limits for self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/usage-limits-for-self-hosted-runners) for self-hosted runner usage limits.

Note

The `GITHUB_TOKEN` expires when a job finishes or after a maximum of 24 hours. For self-hosted runners, the token may be the limiting factor if the job timeout is greater than 24 hours. For more information on the `GITHUB_TOKEN`, see [Automatic token authentication](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#about-the-github_token-secret).

## [`jobs.<job_id>.strategy`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idstrategy)

Use `jobs.<job_id>.strategy` to use a matrix strategy for your jobs. A matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. For example, you can use a matrix strategy to test your code in multiple versions of a language or on multiple operating systems. For more information, see [Running variations of jobs in a workflow](https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs).

## [`jobs.<job_id>.strategy.matrix`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idstrategymatrix)

Use `jobs.<job_id>.strategy.matrix` to define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable called `version` with the value `[10, 12, 14]` and a variable called `os` with the value `[ubuntu-latest, windows-latest]`:

```hljs yaml
jobs:
example_matrix:
    strategy:
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]

```

A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of the `os` and `version` variables.

By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order:

- `{version: 10, os: ubuntu-latest}`
- `{version: 10, os: windows-latest}`
- `{version: 12, os: ubuntu-latest}`
- `{version: 12, os: windows-latest}`
- `{version: 14, os: ubuntu-latest}`
- `{version: 14, os: windows-latest}`

A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners.

The variables that you define become properties in the `matrix` context, and you can reference the property in other areas of your workflow file. In this example, you can use `matrix.version` and `matrix.os` to access the current value of `version` and `os` that the job is using. For more information, see [Contexts reference](https://docs.github.com/en/actions/learn-github-actions/contexts).

### [Example: Using a single-dimension matrix](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-a-single-dimension-matrix)

You can specify a single variable to create a single-dimension matrix.

For example, the following workflow defines the variable `version` with the values `[10, 12, 14]`. The workflow will run three jobs, one for each value in the variable. Each job will access the `version` value through the `matrix.version` context and pass the value as `node-version` to the `actions/setup-node` action.

```hljs yaml
jobs:
example_matrix:
    strategy:
      matrix:
        version: [10, 12, 14]
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}

```

### [Example: Using a multi-dimension matrix](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-a-multi-dimension-matrix)

You can specify multiple variables to create a multi-dimensional matrix. A job will run for each possible combination of the variables.

For example, the following workflow specifies two variables:

- Two operating systems specified in the `os` variable
- Three Node.js versions specified in the `version` variable

The workflow will run six jobs, one for each combination of the `os` and `version` variables. Each job will set the `runs-on` value to the current `os` value and will pass the current `version` value to the `actions/setup-node` action.

```hljs yaml
jobs:
example_matrix:
    strategy:
      matrix:
        os: [ubuntu-22.04, ubuntu-20.04]
        version: [10, 12, 14]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}

```

A variable configuration in a matrix can be an `array` of `object` s.

```hljs yaml
matrix:
os:
    - ubuntu-latest
    - macos-latest
node:
    - version: 14
    - version: 20
      env: NODE_OPTIONS=--openssl-legacy-provider

```

This matrix produces 4 jobs with corresponding contexts.

```hljs yaml
- matrix.os: ubuntu-latest
matrix.node.version: 14
- matrix.os: ubuntu-latest
matrix.node.version: 20
matrix.node.env: NODE_OPTIONS=--openssl-legacy-provider
- matrix.os: macos-latest
matrix.node.version: 14
- matrix.os: macos-latest
matrix.node.version: 20
matrix.node.env: NODE_OPTIONS=--openssl-legacy-provider

```

### [Example: Using contexts to create matrices](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-contexts-to-create-matrices)

You can use contexts to create matrices. For more information about contexts, see [Contexts reference](https://docs.github.com/en/actions/learn-github-actions/contexts).

For example, the following workflow triggers on the `repository_dispatch` event and uses information from the event payload to build the matrix. When a repository dispatch event is created with a payload like the one below, the matrix `version` variable will have a value of `[12, 14, 16]`. For more information about the `repository_dispatch` trigger, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#repository_dispatch).

```hljs json
{
"event_type": "test",
"client_payload": {
    "versions": [12, 14, 16]
}
}

```

```hljs yaml
on:
repository_dispatch:
    types:
      - test

jobs:
example_matrix:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        version: ${{ github.event.client_payload.versions }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.version }}

```

## [`jobs.<job_id>.strategy.matrix.include`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idstrategymatrixinclude)

Use `jobs.<job_id>.strategy.matrix.include` to expand existing matrix configurations or to add new configurations. The value of `include` is a list of objects.

For each object in the `include` list, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten.

For example, this matrix:

```hljs yaml
strategy:
matrix:
    fruit: [apple, pear]
    animal: [cat, dog]
    include:
      - color: green
      - color: pink
        animal: cat
      - fruit: apple
        shape: circle
      - fruit: banana
      - fruit: banana
        animal: cat

```

will result in six jobs with the following matrix combinations:

- `{fruit: apple, animal: cat, color: pink, shape: circle}`
- `{fruit: apple, animal: dog, color: green, shape: circle}`
- `{fruit: pear, animal: cat, color: pink}`
- `{fruit: pear, animal: dog, color: green}`
- `{fruit: banana}`
- `{fruit: banana, animal: cat}`

following this logic:

- `{color: green}` is added to all of the original matrix combinations because it can be added without overwriting any part of the original combinations.
- `{color: pink, animal: cat}` adds `color:pink` only to the original matrix combinations that include `animal: cat`. This overwrites the `color: green` that was added by the previous `include` entry.
- `{fruit: apple, shape: circle}` adds `shape: circle` only to the original matrix combinations that include `fruit: apple`.
- `{fruit: banana}` cannot be added to any original matrix combination without overwriting a value, so it is added as an additional matrix combination.
- `{fruit: banana, animal: cat}` cannot be added to any original matrix combination without overwriting a value, so it is added as an additional matrix combination. It does not add to the `{fruit: banana}` matrix combination because that combination was not one of the original matrix combinations.

### [Example: Expanding configurations](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-expanding-configurations)

For example, the following workflow will run four jobs, one for each combination of `os` and `node`. When the job for the `os` value of `windows-latest` and `node` value of `16` runs, an additional variable called `npm` with the value of `6` will be included in the job.

```hljs yaml
jobs:
example_matrix:
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest]
        node: [14, 16]
        include:
          - os: windows-latest
            node: 16
            npm: 6
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node }}
      - if: ${{ matrix.npm }}
        run: npm install -g npm@${{ matrix.npm }}
      - run: npm --version

```

### [Example: Adding configurations](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-adding-configurations)

For example, this matrix will run 10 jobs, one for each combination of `os` and `version` in the matrix, plus a job for the `os` value of `windows-latest` and `version` value of `17`.

```hljs yaml
jobs:
example_matrix:
    strategy:
      matrix:
        os: [macos-latest, windows-latest, ubuntu-latest]
        version: [12, 14, 16]
        include:
          - os: windows-latest
            version: 17

```

If you don't specify any matrix variables, all configurations under `include` will run. For example, the following workflow would run two jobs, one for each `include` entry. This lets you take advantage of the matrix strategy without having a fully populated matrix.

```hljs yaml
jobs:
includes_only:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - site: "production"
            datacenter: "site-a"
          - site: "staging"
            datacenter: "site-b"

```

## [`jobs.<job_id>.strategy.matrix.exclude`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idstrategymatrixexclude)

To remove specific configurations defined in the matrix, use `jobs.<job_id>.strategy.matrix.exclude`. An excluded configuration only has to be a partial match for it to be excluded. For example, the following workflow will run nine jobs: one job for each of the 12 configurations, minus the one excluded job that matches `{os: macos-latest, version: 12, environment: production}`, and the two excluded jobs that match `{os: windows-latest, version: 16}`.

```hljs yaml
strategy:
matrix:
    os: [macos-latest, windows-latest]
    version: [12, 14, 16]
    environment: [staging, production]
    exclude:
      - os: macos-latest
        version: 12
        environment: production
      - os: windows-latest
        version: 16
runs-on: ${{ matrix.os }}

```

Note

All `include` combinations are processed after `exclude`. This allows you to use `include` to add back combinations that were previously excluded.

## [`jobs.<job_id>.strategy.fail-fast`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idstrategyfail-fast)

You can control how job failures are handled with `jobs.<job_id>.strategy.fail-fast` and `jobs.<job_id>.continue-on-error`.

`jobs.<job_id>.strategy.fail-fast` applies to the entire matrix. If `jobs.<job_id>.strategy.fail-fast` is set to `true` or its expression evaluates to `true`, GitHub will cancel all in-progress and queued jobs in the matrix if any job in the matrix fails. This property defaults to `true`.

`jobs.<job_id>.continue-on-error` applies to a single job. If `jobs.<job_id>.continue-on-error` is `true`, other jobs in the matrix will continue running even if the job with `jobs.<job_id>.continue-on-error: true` fails.

You can use `jobs.<job_id>.strategy.fail-fast` and `jobs.<job_id>.continue-on-error` together. For example, the following workflow will start four jobs. For each job, `continue-on-error` is determined by the value of `matrix.experimental`. If any of the jobs with `continue-on-error: false` fail, all jobs that are in progress or queued will be cancelled. If the job with `continue-on-error: true` fails, the other jobs will not be affected.

```hljs yaml
jobs:
test:
    runs-on: ubuntu-latest
    continue-on-error: ${{ matrix.experimental }}
    strategy:
      fail-fast: true
      matrix:
        version: [6, 7, 8]
        experimental: [false]
        include:
          - version: 9
            experimental: true

```

## [`jobs.<job_id>.strategy.max-parallel`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idstrategymax-parallel)

By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. To set the maximum number of jobs that can run simultaneously when using a `matrix` job strategy, use `jobs.<job_id>.strategy.max-parallel`.

For example, the following workflow will run a maximum of two jobs at a time, even if there are runners available to run all six jobs at once.

```hljs yaml
jobs:
example_matrix:
    strategy:
      max-parallel: 2
      matrix:
        version: [10, 12, 14]
        os: [ubuntu-latest, windows-latest]

```

## [`jobs.<job_id>.continue-on-error`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idcontinue-on-error)

Prevents a workflow run from failing when a job fails. Set to `true` to allow a workflow run to pass when this job fails.

### [Example: Preventing a specific failing matrix job from failing a workflow run](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-preventing-a-specific-failing-matrix-job-from-failing-a-workflow-run)

You can allow specific jobs in a job matrix to fail without failing the workflow run. For example, if you wanted to only allow an experimental job with `node` set to `15` to fail without failing the workflow run.

```hljs yaml
runs-on: ${{ matrix.os }}
continue-on-error: ${{ matrix.experimental }}
strategy:
fail-fast: false
matrix:
    node: [13, 14]
    os: [macos-latest, ubuntu-latest]
    experimental: [false]
    include:
      - node: 15
        os: ubuntu-latest
        experimental: true

```

## [`jobs.<job_id>.container`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idcontainer)

Note

If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner:

- If you are using GitHub-hosted runners, you must use an Ubuntu runner.
- If you are using self-hosted runners, you must use a Linux machine as your runner and Docker must be installed.

Use `jobs.<job_id>.container` to create a container to run any steps in a job that don't already specify a container. If you have steps that use both script and container actions, the container actions will run as sibling containers on the same network with the same volume mounts.

If you do not set a `container`, all steps will run directly on the host specified by `runs-on` unless a step refers to an action configured to run in a container.

Note

The default shell for `run` steps inside a container is `sh` instead of `bash`. This can be overridden with [`jobs.<job_id>.defaults.run`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_iddefaultsrun) or [`jobs.<job_id>.steps[*].shell`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsshell).

### [Example: Running a job within a container](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-running-a-job-within-a-container)

```hljs yaml
name: CI
on:
push:
    branches: [ main ]
jobs:
container-test-job:
    runs-on: ubuntu-latest
    container:
      image: node:18
      env:
        NODE_ENV: development
      ports:
        - 80
      volumes:
        - my_docker_volume:/volume_mount
      options: --cpus 1
    steps:
      - name: Check for dockerenv file
        run: (ls /.dockerenv && echo Found dockerenv) || (echo No dockerenv)

```

When you only specify a container image, you can omit the `image` keyword.

```hljs yaml
jobs:
container-test-job:
    runs-on: ubuntu-latest
    container: node:18

```

## [`jobs.<job_id>.container.image`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idcontainerimage)

Use `jobs.<job_id>.container.image` to define the Docker image to use as the container to run the action. The value can be the Docker Hub image name or a registry name.

Note

Docker Hub normally imposes rate limits on both push and pull operations which will affect jobs on self-hosted runners. However, GitHub-hosted runners are not subject to these limits based on an agreement between GitHub and Docker.

## [`jobs.<job_id>.container.credentials`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idcontainercredentials)

If the image's container registry requires authentication to pull the image, you can use `jobs.<job_id>.container.credentials` to set a `map` of the `username` and `password`. The credentials are the same values that you would provide to the [`docker login`](https://docs.docker.com/engine/reference/commandline/login/) command.

### [Example: Defining credentials for a container registry](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-defining-credentials-for-a-container-registry)

```hljs yaml
container:
image: ghcr.io/owner/image
credentials:
     username: ${{ github.actor }}
     password: ${{ secrets.github_token }}

```

## [`jobs.<job_id>.container.env`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idcontainerenv)

Use `jobs.<job_id>.container.env` to set a `map` of environment variables in the container.

## [`jobs.<job_id>.container.ports`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idcontainerports)

Use `jobs.<job_id>.container.ports` to set an `array` of ports to expose on the container.

## [`jobs.<job_id>.container.volumes`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idcontainervolumes)

Use `jobs.<job_id>.container.volumes` to set an `array` of volumes for the container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host.

To specify a volume, you specify the source and destination path:

`<source>:<destinationPath>`.

The `<source>` is a volume name or an absolute path on the host machine, and `<destinationPath>` is an absolute path in the container.

### [Example: Mounting volumes in a container](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-mounting-volumes-in-a-container)

```hljs yaml
volumes:
  - my_docker_volume:/volume_mount
  - /data/my_data
  - /source/directory:/destination/directory

```

## [`jobs.<job_id>.container.options`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idcontaineroptions)

Use `jobs.<job_id>.container.options` to configure additional Docker container resource options. For a list of options, see [`docker create` options](https://docs.docker.com/engine/reference/commandline/create/#options).

Warning

The `--network` and `--entrypoint` options are not supported.

## [`jobs.<job_id>.services`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idservices)

Note

If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner:

- If you are using GitHub-hosted runners, you must use an Ubuntu runner.
- If you are using self-hosted runners, you must use a Linux machine as your runner and Docker must be installed.

Used to host service containers for a job in a workflow. Service containers are useful for creating databases or cache services like Redis. The runner automatically creates a Docker network and manages the life cycle of the service containers.

If you configure your job to run in a container, or your step uses container actions, you don't need to map ports to access the service or action. Docker automatically exposes all ports between containers on the same Docker user-defined bridge network. You can directly reference the service container by its hostname. The hostname is automatically mapped to the label name you configure for the service in the workflow.

If you configure the job to run directly on the runner machine and your step doesn't use a container action, you must map any required Docker service container ports to the Docker host (the runner machine). You can access the service container using localhost and the mapped port.

For more information about the differences between networking service containers, see [About service containers](https://docs.github.com/en/actions/using-containerized-services/about-service-containers).

### [Example: Using localhost](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-using-localhost)

This example creates two services: nginx and redis. When you specify the container port but not the host port, the container port is randomly assigned to a free port on the host. GitHub sets the assigned host port in the `${{job.services.<service_name>.ports}}` context. In this example, you can access the service host ports using the `${{ job.services.nginx.ports['80'] }}` and `${{ job.services.redis.ports['6379'] }}` contexts.

```hljs yaml
services:
nginx:
    image: nginx
    # Map port 8080 on the Docker host to port 80 on the nginx container
    ports:
      - 8080:80
redis:
    image: redis
    # Map random free TCP port on Docker host to port 6379 on redis container
    ports:
      - 6379/tcp
steps:
  - run: |
      echo "Redis available on 127.0.0.1:${{ job.services.redis.ports['6379'] }}"
      echo "Nginx available on 127.0.0.1:${{ job.services.nginx.ports['80'] }}"

```

## [`jobs.<job_id>.services.<service_id>.image`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idservicesservice_idimage)

The Docker image to use as the service container to run the action. The value can be the Docker Hub image name or a registry name.

If `jobs.<job_id>.services.<service_id>.image` is assigned an empty string, the service will not start. You can use this to set up conditional services, similar to the following example.

```hljs yaml
services:
nginx:
    image: ${{ options.nginx == true && 'nginx' || '' }}

```

## [`jobs.<job_id>.services.<service_id>.credentials`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idservicesservice_idcredentials)

If the image's container registry requires authentication to pull the image, you can use `jobs.<job_id>.container.credentials` to set a `map` of the `username` and `password`. The credentials are the same values that you would provide to the [`docker login`](https://docs.docker.com/engine/reference/commandline/login/) command.

### [Example of `jobs.<job_id>.services.<service_id>.credentials`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-of-jobsjob_idservicesservice_idcredentials)

```hljs yaml
services:
myservice1:
    image: ghcr.io/owner/myservice1
    credentials:
      username: ${{ github.actor }}
      password: ${{ secrets.github_token }}
myservice2:
    image: dockerhub_org/myservice2
    credentials:
      username: ${{ secrets.DOCKER_USER }}
      password: ${{ secrets.DOCKER_PASSWORD }}

```

## [`jobs.<job_id>.services.<service_id>.env`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idservicesservice_idenv)

Sets a `map` of environment variables in the service container.

## [`jobs.<job_id>.services.<service_id>.ports`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idservicesservice_idports)

Sets an `array` of ports to expose on the service container.

## [`jobs.<job_id>.services.<service_id>.volumes`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idservicesservice_idvolumes)

Sets an `array` of volumes for the service container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host.

To specify a volume, you specify the source and destination path:

`<source>:<destinationPath>`.

The `<source>` is a volume name or an absolute path on the host machine, and `<destinationPath>` is an absolute path in the container.

### [Example of `jobs.<job_id>.services.<service_id>.volumes`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-of-jobsjob_idservicesservice_idvolumes)

```hljs yaml
volumes:
  - my_docker_volume:/volume_mount
  - /data/my_data
  - /source/directory:/destination/directory

```

## [`jobs.<job_id>.services.<service_id>.options`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idservicesservice_idoptions)

Additional Docker container resource options. For a list of options, see [`docker create` options](https://docs.docker.com/engine/reference/commandline/create/#options).

Warning

The `--network` option is not supported.

## [`jobs.<job_id>.uses`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_iduses)

The location and version of a reusable workflow file to run as a job. Use one of the following syntaxes:

- `{owner}/{repo}/.github/workflows/{filename}@{ref}` for reusable workflows in public and private repositories.
- `./.github/workflows/{filename}` for reusable workflows in the same repository.

In the first option, `{ref}` can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#reusing-third-party-workflows).

If you use the second syntax option (without `{owner}/{repo}` and `@{ref}`) the called workflow is from the same commit as the caller workflow. Ref prefixes such as `refs/heads` and `refs/tags` are not allowed. You cannot use contexts or expressions in this keyword.

### [Example of `jobs.<job_id>.uses`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-of-jobsjob_iduses)

```hljs yaml
jobs:
call-workflow-1-in-local-repo:
    uses: octo-org/this-repo/.github/workflows/workflow-1.yml@172239021f7ba04fe7327647b213799853a9eb89
call-workflow-2-in-local-repo:
    uses: ./.github/workflows/workflow-2.yml
call-workflow-in-another-repo:
    uses: octo-org/another-repo/.github/workflows/workflow.yml@v1

```

For more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).

## [`jobs.<job_id>.with`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idwith)

When a job is used to call a reusable workflow, you can use `with` to provide a map of inputs that are passed to the called workflow.

Any inputs that you pass must match the input specifications defined in the called workflow.

Unlike [`jobs.<job_id>.steps[*].with`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstepswith), the inputs you pass with `jobs.<job_id>.with` are not available as environment variables in the called workflow. Instead, you can reference the inputs by using the `inputs` context.

### [Example of `jobs.<job_id>.with`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-of-jobsjob_idwith)

```hljs yaml
jobs:
call-workflow:
    uses: octo-org/example-repo/.github/workflows/called-workflow.yml@main
    with:
      username: mona

```

## [`jobs.<job_id>.with.<input_id>`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idwithinput_id)

A pair consisting of a string identifier for the input and the value of the input. The identifier must match the name of an input defined by [`on.workflow_call.inputs.<inputs_id>`](https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#inputsinput_id) in the called workflow. The data type of the value must match the type defined by [`on.workflow_call.inputs.<input_id>.type`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#onworkflow_callinputsinput_idtype) in the called workflow.

Allowed expression contexts: `github`, and `needs`.

## [`jobs.<job_id>.secrets`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idsecrets)

When a job is used to call a reusable workflow, you can use `secrets` to provide a map of secrets that are passed to the called workflow.

Any secrets that you pass must match the names defined in the called workflow.

### [Example of `jobs.<job_id>.secrets`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-of-jobsjob_idsecrets)

```hljs yaml
jobs:
call-workflow:
    uses: octo-org/example-repo/.github/workflows/called-workflow.yml@main
    secrets:
      access-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

```

## [`jobs.<job_id>.secrets.inherit`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idsecretsinherit)

Use the `inherit` keyword to pass all the calling workflow's secrets to the called workflow. This includes all secrets the calling workflow has access to, namely organization, repository, and environment secrets. The `inherit` keyword can be used to pass secrets across repositories within the same organization, or across organizations within the same enterprise.

### [Example of `jobs.<job_id>.secrets.inherit`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#example-of-jobsjob_idsecretsinherit)

```hljs yaml
on:
workflow_dispatch:

jobs:
pass-secrets-to-workflow:
    uses: ./.github/workflows/called-workflow.yml
    secrets: inherit

```

```hljs yaml
on:
workflow_call:

jobs:
pass-secret-to-action:
    runs-on: ubuntu-latest
    steps:
      - name: Use a repo or org secret from the calling workflow.
        run: echo ${{ secrets.CALLING_WORKFLOW_SECRET }}

```

## [`jobs.<job_id>.secrets.<secret_id>`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#jobsjob_idsecretssecret_id)

A pair consisting of a string identifier for the secret and the value of the secret. The identifier must match the name of a secret defined by [`on.workflow_call.secrets.<secret_id>`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#onworkflow_callsecretssecret_id) in the called workflow.

Allowed expression contexts: `github`, `needs`, and `secrets`.

## [Filter pattern cheat sheet](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#filter-pattern-cheat-sheet)

You can use special characters in path, branch, and tag filters.

- `*`: Matches zero or more characters, but does not match the `/` character. For example, `Octo*` matches `Octocat`.
- `**`: Matches zero or more of any character.
- `?`: Matches zero or one of the preceding character.
- `+`: Matches one or more of the preceding character.
- `[]` Matches one alphanumeric character listed in the brackets or included in ranges. Ranges can only include `a-z`, `A-Z`, and `0-9`. For example, the range `[0-9a-z]` matches any digit or lowercase letter. For example, `[CB]at` matches `Cat` or `Bat` and `[1-2]00` matches `100` and `200`.
- `!`: At the start of a pattern makes it negate previous positive patterns. It has no special meaning if not the first character.

The characters `*`, `[`, and `!` are special characters in YAML. If you start a pattern with `*`, `[`, or `!`, you must enclose the pattern in quotes. Also, if you use a [flow sequence](https://yaml.org/spec/1.2.2/#flow-sequences) with a pattern containing `[` and/or `]`, the pattern must be enclosed in quotes.\
\
```hljs yaml\
# Valid\
paths:\
  - '**/README.md'\
\
# Invalid - creates a parse error that\
# prevents your workflow from running.\
paths:\
  - **/README.md\
\
# Valid\
branches: [ main, 'release/v[0-9].[0-9]' ]\
\
# Invalid - creates a parse error\
branches: [ main, release/v[0-9].[0-9] ]\
\
```\
\
For more information about branch, tag, and path filter syntax, see [`on.<push>.<branches|tags>`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#onpushbranchestagsbranches-ignoretags-ignore), [`on.<pull_request>.<branches|tags>`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#onpull_requestpull_request_targetbranchesbranches-ignore), and [`on.<push|pull_request>.paths`](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).\
\
### [Patterns to match branches and tags](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#patterns-to-match-branches-and-tags)\
\
| Pattern | Description | Example matches |\
| --- | --- | --- |\
| `feature/*` | The `*` wildcard matches any character, but does not match slash ( `/`). | `feature/my-branch`<br>`feature/your-branch` |\
| `feature/**` | The `**` wildcard matches any character including slash ( `/`) in branch and tag names. | `feature/beta-a/my-branch`<br>`feature/your-branch`<br>`feature/mona/the/octocat` |\
| `main`<br>`releases/mona-the-octocat` | Matches the exact name of a branch or tag name. | `main`<br>`releases/mona-the-octocat` |\
| `'*'` | Matches all branch and tag names that don't contain a slash ( `/`). The `*` character is a special character in YAML. When you start a pattern with `*`, you must use quotes. | `main`<br>`releases` |\
| `'**'` | Matches all branch and tag names. This is the default behavior when you don't use a `branches` or `tags` filter. | `all/the/branches`<br>`every/tag` |\
| `'*feature'` | The `*` character is a special character in YAML. When you start a pattern with `*`, you must use quotes. | `mona-feature`<br>`feature`<br>`ver-10-feature` |\
| `v2*` | Matches branch and tag names that start with `v2`. | `v2`<br>`v2.0`<br>`v2.9` |\
| `v[12].[0-9]+.[0-9]+` | Matches all semantic versioning branches and tags with major version 1 or 2. | `v1.10.1`<br>`v2.0.0` |\
\
### [Patterns to match file paths](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\#patterns-to-match-file-paths)\
\
Path patterns must match the whole path, and start from the repository's root.\
\
| Pattern | Description of matches | Example matches |\
| --- | --- | --- |\
| `'*'` | The `*` wildcard matches any character, but does not match slash ( `/`). The `*` character is a special character in YAML. When you start a pattern with `*`, you must use quotes. | `README.md`<br>`server.rb` |\
| `'*.jsx?'` | The `?` character matches zero or one of the preceding character. | `page.js`<br>`page.jsx` |\
| `'**'` | The `**` wildcard matches any character including slash ( `/`). This is the default behavior when you don't use a `path` filter. | `all/the/files.md` |\
| `'*.js'` | The `*` wildcard matches any character, but does not match slash ( `/`). Matches all `.js` files at the root of the repository. | `app.js`<br>`index.js` |\
| `'**.js'` | Matches all `.js` files in the repository. | `index.js`<br>`js/index.js`<br>`src/js/app.js` |\
| `docs/*` | All files within the root of the `docs` directory only, at the root of the repository. | `docs/README.md`<br>`docs/file.txt` |\
| `docs/**` | Any files in the `docs` directory and its subdirectories at the root of the repository. | `docs/README.md`<br>`docs/mona/octocat.txt` |\
| `docs/**/*.md` | A file with a `.md` suffix anywhere in the `docs` directory. | `docs/README.md`<br>`docs/mona/hello-world.md`<br>`docs/a/markdown/file.md` |\
| `'**/docs/**'` | Any files in a `docs` directory anywhere in the repository. | `docs/hello.md`<br>`dir/docs/my-file.txt`<br>`space/docs/plan/space.doc` |\
| `'**/README.md'` | A README.md file anywhere in the repository. | `README.md`<br>`js/README.md` |\
| `'**/*src/**'` | Any file in a folder with a `src` suffix anywhere in the repository. | `a/src/app.js`<br>`my-src/code/js/app.js` |\
| `'**/*-post.md'` | A file with the suffix `-post.md` anywhere in the repository. | `my-post.md`<br>`path/their-post.md` |\
| `'**/migrate-*.sql'` | A file with the prefix `migrate-` and suffix `.sql` anywhere in the repository. | `migrate-10909.sql`<br>`db/migrate-v1.0.sql`<br>`db/sept/migrate-v1.sql` |\
| `'*.md'`<br>`'!README.md'` | Using an exclamation mark ( `!`) in front of a pattern negates it. When a file matches a pattern and also matches a negative pattern defined later in the file, the file will not be included. | `hello.md`<br>_Does not match_<br>`README.md`<br>`docs/hello.md` |\
| `'*.md'`<br>`'!README.md'`<br>`README*` | Patterns are checked sequentially. A pattern that negates a previous pattern will re-include file paths. | `hello.md`<br>`README.md`<br>`README.doc` |

---


## 2. Events that trigger workflows {#section-2}

*Source: [https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows)*


# Events that trigger workflows

You can configure your workflows to run when specific activity on GitHub happens, at a scheduled time, or when an event outside of GitHub occurs.

## In this article

## [About events that trigger workflows](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#about-events-that-trigger-workflows)

Workflow triggers are events that cause a workflow to run. For more information about how to use workflow triggers, see [Triggering a workflow](https://docs.github.com/en/actions/using-workflows/triggering-a-workflow).

Some events have multiple activity types. For these events, you can specify which activity types will trigger a workflow run. For more information about what each activity type means, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads).

Note

Not all webhook events trigger workflows.

## [`branch_protection_rule`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#branch_protection_rule)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`branch_protection_rule`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#branch_protection_rule) | \- `created`<br>\- `edited`<br>\- `deleted` | Last commit on default branch | Default branch |

Note

More than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#branch_protection_rule). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when branch protection rules in the workflow repository are changed. For more information about branch protection rules, see [About protected branches](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches). For information about the branch protection rule APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#branchprotectionrule) in the GraphQL API documentation or [REST API endpoints for branches and their settings](https://docs.github.com/en/rest/branches).

For example, you can run a workflow when a branch protection rule has been `created` or `deleted`:

```hljs yaml
on:
  branch_protection_rule:
    types: [created, deleted]

```

## [`check_run`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#check_run)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`check_run`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#check_run) | \- `created`<br>\- `rerequested`<br>\- `completed`<br>\- `requested_action` | Last commit on default branch | Default branch |

Note

More than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#check_run). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when activity related to a check run occurs. A check run is an individual test that is part of a check suite. For information, see [Using the REST API to interact with checks](https://docs.github.com/en/rest/guides/using-the-rest-api-to-interact-with-checks). For information about the check run APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#checkrun) in the GraphQL API documentation or [REST API endpoints for check runs](https://docs.github.com/en/rest/checks/runs).

For example, you can run a workflow when a check run has been `rerequested` or `completed`.

```hljs yaml
on:
  check_run:
    types: [rerequested, completed]

```

## [`check_suite`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#check_suite)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`check_suite`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#check_suite) | \- `completed` | Last commit on default branch | Default branch |

Note

More than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#check_suite). Although only the `completed` activity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Note

To prevent recursive workflows, this event does not trigger workflows if the check suite was created by GitHub Actions.

Runs your workflow when check suite activity occurs. A check suite is a collection of the check runs created for a specific commit. Check suites summarize the status and conclusion of the check runs that are in the suite. For information, see [Using the REST API to interact with checks](https://docs.github.com/en/rest/guides/using-the-rest-api-to-interact-with-checks). For information about the check suite APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#checksuite) in the GraphQL API documentation or [REST API endpoints for check suites](https://docs.github.com/en/rest/checks/suites).

For example, you can run a workflow when a check suite has been `completed`.

```hljs yaml
on:
  check_suite:
    types: [completed]

```

## [`create`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#create)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`create`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#create) | Not applicable | Last commit on the created branch or tag | Branch or tag created |

Note

An event will not be created when you create more than three tags at once.

Runs your workflow when someone creates a Git reference (Git branch or tag) in the workflow's repository. For information about the APIs to create a Git reference, see [Mutations](https://docs.github.com/en/graphql/reference/mutations#createref) in the GraphQL API documentation or [REST API endpoints for Git references](https://docs.github.com/en/rest/git/refs#create-a-reference).

For example, you can run a workflow when the `create` event occurs.

```hljs yaml
on:
  create

```

## [`delete`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#delete)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`delete`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#delete) | Not applicable | Last commit on default branch | Default branch |

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Note

An event will not be created when you delete more than three tags at once.

Runs your workflow when someone deletes a Git reference (Git branch or tag) in the workflow's repository. For information about the APIs to delete a Git reference, see [Mutations](https://docs.github.com/en/graphql/reference/mutations#deleteref) in the GraphQL API documentation or [REST API endpoints for Git references](https://docs.github.com/en/rest/git/refs#delete-a-reference).

For example, you can run a workflow when the `delete` event occurs.

```hljs yaml
on:
  delete

```

## [`deployment`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#deployment)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`deployment`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#deployment) | Not applicable | Commit to be deployed | Branch or tag to be deployed (empty if created with a commit SHA) |

Runs your workflow when someone creates a deployment in the workflow's repository. Deployments created with a commit SHA may not have a Git ref. For information about the APIs to create a deployment, see [Mutations](https://docs.github.com/en/graphql/reference/mutations#createdeployment) in the GraphQL API documentation or [REST API endpoints for repositories](https://docs.github.com/en/rest/repos#deployments).

For example, you can run a workflow when the `deployment` event occurs.

```hljs yaml
on:
  deployment

```

## [`deployment_status`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#deployment_status)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`deployment_status`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#deployment_status) | Not applicable | Commit to be deployed | Branch or tag to be deployed (empty if commit) |

Note

When a deployment status's state is set to `inactive`, a workflow run will not be triggered.

Runs your workflow when a third party provides a deployment status. Deployments created with a commit SHA may not have a Git ref. For information about the APIs to create a deployment status, see [Mutations](https://docs.github.com/en/graphql/reference/mutations#createdeploymentstatus) in the GraphQL API documentation or [REST API endpoints for deployments](https://docs.github.com/en/rest/deployments#create-a-deployment-status).

For example, you can run a workflow when the `deployment_status` event occurs.

```hljs yaml
on:
  deployment_status

```

## [`discussion`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#discussion)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`discussion`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#discussion) | \- `created`<br>\- `edited`<br>\- `deleted`<br>\- `transferred`<br>\- `pinned`<br>\- `unpinned`<br>\- `labeled`<br>\- `unlabeled`<br>\- `locked`<br>\- `unlocked`<br>\- `category_changed`<br> \- `answered`<br> \- `unanswered` | Last commit on default branch | Default branch |

Note

More than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#discussion). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Note

Webhook events for GitHub Discussions are currently in public preview and subject to change.

Runs your workflow when a discussion in the workflow's repository is created or modified. For activity related to comments on a discussion, use the [`discussion_comment`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#discussion_comment) event. For more information about discussions, see [About discussions](https://docs.github.com/en/discussions/collaborating-with-your-community-using-discussions/about-discussions). For information about the GraphQL API, see [Objects](https://docs.github.com/en/graphql/reference/objects#discussion).

For example, you can run a workflow when a discussion has been `created`, `edited`, or `answered`.

```hljs yaml
on:
  discussion:
    types: [created, edited, answered]

```

## [`discussion_comment`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#discussion_comment)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`discussion_comment`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#discussion_comment) | \- `created`<br>\- `edited`<br>\- `deleted` | Last commit on default branch | Default branch |

Note

More than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#discussion_comment). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Note

Webhook events for GitHub Discussions are currently in public preview and subject to change.

Runs your workflow when a comment on a discussion in the workflow's repository is created or modified. For activity related to a discussion as opposed to comments on the discussion, use the [`discussion`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#discussion) event. For more information about discussions, see [About discussions](https://docs.github.com/en/discussions/collaborating-with-your-community-using-discussions/about-discussions). For information about the GraphQL API, see [Objects](https://docs.github.com/en/graphql/reference/objects#discussion).

For example, you can run a workflow when a discussion comment has been `created` or `deleted`.

```hljs yaml
on:
  discussion_comment:
    types: [created, deleted]

```

## [`fork`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#fork)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`fork`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#fork) | Not applicable | Last commit on default branch | Default branch |

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when someone forks a repository. For information about the REST API, see [REST API endpoints for forks](https://docs.github.com/en/rest/repos/forks#create-a-fork).

For example, you can run a workflow when the `fork` event occurs.

```hljs yaml
on:
  fork

```

## [`gollum`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#gollum)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`gollum`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#gollum) | Not applicable | Last commit on default branch | Default branch |

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when someone creates or updates a Wiki page. For more information, see [About wikis](https://docs.github.com/en/communities/documenting-your-project-with-wikis/about-wikis).

For example, you can run a workflow when the `gollum` event occurs.

```hljs yaml
on:
  gollum

```

## [`issue_comment`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#issue_comment)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`issue_comment`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#issue_comment) | \- `created`<br>\- `edited`<br>\- `deleted` | Last commit on default branch | Default branch |

Note

More than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#issue_comment). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when an issue or pull request comment is created, edited, or deleted. For information about the issue comment APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#issuecomment) in the GraphQL API documentation or [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#issue_comment) in the REST API documentation.

For example, you can run a workflow when an issue or pull request comment has been `created` or `deleted`.

```hljs yaml
on:
  issue_comment:
    types: [created, deleted]

```

### [`issue_comment` on issues only or pull requests only](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#issue_comment-on-issues-only-or-pull-requests-only)

The `issue_comment` event occurs for comments on both issues and pull requests. You can use the `github.event.issue.pull_request` property in a conditional to take different action depending on whether the triggering object was an issue or pull request.

For example, this workflow will run the `pr_commented` job only if the `issue_comment` event originated from a pull request. It will run the `issue_commented` job only if the `issue_comment` event originated from an issue.

```hljs yaml
on: issue_comment

jobs:
  pr_commented:
    # This job only runs for pull request comments
    name: PR comment
    if: ${{ github.event.issue.pull_request }}
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo A comment on PR $NUMBER
        env:
          NUMBER: ${{ github.event.issue.number }}

  issue_commented:
    # This job only runs for issue comments
    name: Issue comment
    if: ${{ !github.event.issue.pull_request }}
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo A comment on issue $NUMBER
        env:
          NUMBER: ${{ github.event.issue.number }}

```

## [`issues`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#issues)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`issues`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#issues) | \- `opened`<br>\- `edited`<br>\- `deleted`<br>\- `transferred`<br>\- `pinned`<br>\- `unpinned`<br>\- `closed`<br>\- `reopened`<br>\- `assigned`<br>\- `unassigned`<br>\- `labeled`<br>\- `unlabeled`<br>\- `locked`<br>\- `unlocked`<br>\- `milestoned`<br> \- `demilestoned`<br> \- `typed`<br> \- `untyped` | Last commit on default branch | Default branch |

Note

More than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#issues). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when an issue in the workflow's repository is created or modified. For activity related to comments in an issue, use the [`issue_comment`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#issue_comment) event. For more information about issues, see [About issues](https://docs.github.com/en/issues/tracking-your-work-with-issues/about-issues). For information about the issue APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#issue) in the GraphQL API documentation or [REST API endpoints for issues](https://docs.github.com/en/rest/issues).

For example, you can run a workflow when an issue has been `opened`, `edited`, or `milestoned`.

```hljs yaml
on:
  issues:
    types: [opened, edited, milestoned]

```

## [`label`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#label)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`label`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#label) | \- `created`<br>\- `edited`<br>\- `deleted` | Last commit on default branch | Default branch |

Note

More than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#label). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when a label in your workflow's repository is created or modified. For more information about labels, see [Managing labels](https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/managing-labels). For information about the label APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#label) in the GraphQL API documentation or [REST API endpoints for labels](https://docs.github.com/en/rest/issues/labels).

If you want to run your workflow when a label is added to or removed from an issue, pull request, or discussion, use the `labeled` or `unlabeled` activity types for the [`issues`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#issues), [`pull_request`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#pull_request), [`pull_request_target`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#pull_request_target), or [`discussion`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#discussion) events instead.

For example, you can run a workflow when a label has been `created` or `deleted`.

```hljs yaml
on:
  label:
    types: [created, deleted]

```

## [`merge_group`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#merge_group)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`merge_group`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#merge_group) | `checks_requested` | SHA of the merge group | Ref of the merge group |

Note

- More than one activity type triggers this event. Although only the `checks_requested` activity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#merge_group). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).
- If your repository uses GitHub Actions to perform required checks on pull requests in your repository, you need to update the workflows to include the `merge_group` event as an additional trigger. Otherwise, status checks will not be triggered when you add a pull request to a merge queue. The merge will fail as the required status check will not be reported. The `merge_group` event is separate from the `pull_request` and `push` events.

Runs your workflow when a pull request is added to a merge queue, which adds the pull request to a merge group. For more information see [Merging a pull request with a merge queue](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/incorporating-changes-from-a-pull-request/merging-a-pull-request-with-a-merge-queue).

For example, you can run a workflow when the `checks_requested` activity has occurred.

```hljs yaml
on:
  pull_request:
    branches: [ "main" ]
  merge_group:
    types: [checks_requested]

```

## [`milestone`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#milestone)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`milestone`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#milestone) | \- `created`<br>\- `closed`<br>\- `opened`<br>\- `edited`<br>\- `deleted` | Last commit on default branch | Default branch |

Note

More than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#milestone). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when a milestone in the workflow's repository is created or modified. For more information about milestones, see [About milestones](https://docs.github.com/en/issues/using-labels-and-milestones-to-track-work/about-milestones). For information about the milestone APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#milestone) in the GraphQL API documentation or [REST API endpoints for milestones](https://docs.github.com/en/rest/issues/milestones).

If you want to run your workflow when an issue is added to or removed from a milestone, use the `milestoned` or `demilestoned` activity types for the [`issues`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#issues) event instead.

For example, you can run a workflow when a milestone has been `opened` or `deleted`.

```hljs yaml
on:
  milestone:
    types: [opened, deleted]

```

## [`page_build`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#page_build)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`page_build`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#page_build) | Not applicable | Last commit on default branch | Default branch |

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when someone pushes to a branch that is the publishing source for GitHub Pages, if GitHub Pages is enabled for the repository. For more information about GitHub Pages publishing sources, see [Configuring a publishing source for your GitHub Pages site](https://docs.github.com/en/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site). For information about the REST API, see [REST API endpoints for repositories](https://docs.github.com/en/rest/repos#pages).

For example, you can run a workflow when the `page_build` event occurs.

```hljs yaml
on:
  page_build

```

## [`public`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#public)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`public`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#public) | Not applicable | Last commit on default branch | Default branch |

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when your workflow's repository changes from private to public. For information about the REST API, see [REST API endpoints for repositories](https://docs.github.com/en/rest/repos#edit).

For example, you can run a workflow when the `public` event occurs.

```hljs yaml
on:
  public

```

## [`pull_request`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#pull_request)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`pull_request`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#pull_request) | \- `assigned`<br>\- `unassigned`<br>\- `labeled`<br>\- `unlabeled`<br>\- `opened`<br>\- `edited`<br>\- `closed`<br>\- `reopened`<br>\- `synchronize`<br>\- `converted_to_draft`<br>\- `locked`<br>\- `unlocked`<br>\- `enqueued`<br>\- `dequeued`<br>\- `milestoned`<br>\- `demilestoned`<br>\- `ready_for_review`<br>\- `review_requested`<br>\- `review_request_removed`<br>\- `auto_merge_enabled`<br>\- `auto_merge_disabled` | Last merge commit on the `GITHUB_REF` branch | PR merge branch `refs/pull/PULL_REQUEST_NUMBER/merge` |

Note

- More than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#pull_request). By default, a workflow only runs when a `pull_request` event's activity type is `opened`, `synchronize`, or `reopened`. To trigger workflows by different activity types, use the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).
- Workflows will not run on `pull_request` activity if the pull request has a merge conflict. The merge conflict must be resolved first.
Conversely, workflows with the `pull_request_target` event will run even if the pull request has a merge conflict. Before using the `pull_request_target` trigger, you should be aware of the security risks. For more information, see [`pull_request_target`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#pull_request_target).
- The `pull_request` webhook event payload is empty for merged pull requests and pull requests that come from forked repositories.
- The value of `GITHUB_REF` varies for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will be `refs/pull/PULL_REQUEST_NUMBER/merge`. If a pull request was closed as a result of being merged, it will be the fully qualified `ref` of the branch it was merged into, for example `/refs/heads/main`.

Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use the [`pull_request_review`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#pull_request_review), [`pull_request_review_comment`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#pull_request_review_comment), or [`issue_comment`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#issue_comment) events instead. For information about the pull request APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#pullrequest) in the GraphQL API documentation or [REST API endpoints for pull requests](https://docs.github.com/en/rest/pulls).

Note that `GITHUB_SHA` for this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, use `github.event.pull_request.head.sha` instead.

For example, you can run a workflow when a pull request has been opened or reopened.

```hljs yaml
on:
  pull_request:
    types: [opened, reopened]

```

You can use the event context to further control when jobs in your workflow will run. For example, this workflow will run when a review is requested on a pull request, but the `specific_review_requested` job will only run when a review by `octo-team` is requested.

```hljs yaml
on:
  pull_request:
    types: [review_requested]
jobs:
  specific_review_requested:
    runs-on: ubuntu-latest
    if: ${{ github.event.requested_team.name == 'octo-team'}}
    steps:
      - run: echo 'A review from octo-team was requested'

```

### [Running your `pull_request` workflow based on the head or base branch of a pull request](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#running-your-pull_request-workflow-based-on-the-head-or-base-branch-of-a-pull-request)

You can use the `branches` or `branches-ignore` filter to configure your workflow to only run on pull requests that target specific branches. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpull_requestpull_request_targetbranchesbranches-ignore).

For example, this workflow will run when someone opens a pull request that targets a branch whose name starts with `releases/`:

```hljs yaml
on:
  pull_request:
    types:
      - opened
    branches:
      - 'releases/**'

```

Note

If you use both the `branches` filter and the `paths` filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript ( `.js`) file is opened on a branch whose name starts with `releases/`:

```hljs yaml
on:
  pull_request:
    types:
      - opened
    branches:
      - 'releases/**'
    paths:
      - '**.js'

```

To run a job based on the pull request's head branch name (as opposed to the pull request's base branch name), use the `github.head_ref` context in a conditional. For example, this workflow will run whenever a pull request is opened, but the `run_if` job will only execute if the head of the pull request is a branch whose name starts with `releases/`:

```hljs yaml
on:
  pull_request:
    types:
      - opened
jobs:
  run_if:
    if: startsWith(github.head_ref, 'releases/')
    runs-on: ubuntu-latest
    steps:
      - run: echo "The head of this PR starts with 'releases/'"

```

### [Running your `pull_request` workflow based on files changed in a pull request](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#running-your-pull_request-workflow-based-on-files-changed-in-a-pull-request)

You can also configure your workflow to run when a pull request changes specific files. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).

For example, this workflow will run when a pull request includes a change to a JavaScript file ( `.js`):

```hljs yaml
on:
  pull_request:
    paths:
      - '**.js'

```

Note

If you use both the `branches` filter and the `paths` filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript ( `.js`) file is opened on a branch whose name starts with `releases/`:

```hljs yaml
on:
  pull_request:
    types:
      - opened
    branches:
      - 'releases/**'
    paths:
      - '**.js'

```

### [Running your `pull_request` workflow when a pull request merges](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#running-your-pull_request-workflow-when-a-pull-request-merges)

When a pull request merges, the pull request is automatically closed. To run a workflow when a pull request merges, use the `pull_request` `closed` event type along with a conditional that checks the `merged` value of the event. For example, the following workflow will run whenever a pull request closes. The `if_merged` job will only run if the pull request was also merged.

```hljs yaml
on:
  pull_request:
    types:
      - closed

jobs:
  if_merged:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
    - run: |
        echo The PR was merged

```

#### [Workflows in forked repositories](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#workflows-in-forked-repositories)

Workflows don't run in forked repositories by default. You must enable GitHub Actions in the **Actions** tab of the forked repository.

With the exception of `GITHUB_TOKEN`, secrets are not passed to the runner when a workflow is triggered from a forked repository. The `GITHUB_TOKEN` has read-only permissions in pull requests from forked repositories. For more information, see [Automatic token authentication](https://docs.github.com/en/actions/security-guides/automatic-token-authentication).

#### [Pull request events for forked repositories](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#pull-request-events-for-forked-repositories)

For pull requests from a forked repository to the base repository, GitHub sends the `pull_request`, `issue_comment`, `pull_request_review_comment`, `pull_request_review`, and `pull_request_target` events to the base repository. No pull request events occur on the forked repository.

When a first-time contributor submits a pull request to a public repository, a maintainer with write access may need to approve running workflows on the pull request. For more information, see [Approving workflow runs from public forks](https://docs.github.com/en/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks).

For pull requests from a forked repository to a private repository, workflows only run when they are enabled, see [Managing GitHub Actions settings for a repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#enabling-workflows-for-forks-of-private-repositories).

Note

Workflows triggered by Dependabot pull requests are treated as though they are from a forked repository, and are also subject to these restrictions.

## [`pull_request_comment` (use `issue_comment`)](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#pull_request_comment-use-issue_comment)

To run your workflow when a comment on a pull request (not on a pull request's diff) is created, edited, or deleted, use the [`issue_comment`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#issue_comment) event. For activity related to pull request reviews or pull request review comments, use the [`pull_request_review`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#pull_request_review) or [`pull_request_review_comment`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#pull_request_review_comment) events.

## [`pull_request_review`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#pull_request_review)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`pull_request_review`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#pull_request_review) | \- `submitted`<br>\- `edited`<br>\- `dismissed` | Last merge commit on the `GITHUB_REF` branch | PR merge branch `refs/pull/PULL_REQUEST_NUMBER/merge` |

Note

More than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#pull_request_review). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).

Runs your workflow when a pull request review is submitted, edited, or dismissed. A pull request review is a group of pull request review comments in addition to a body comment and a state. For activity related to pull request review comments or pull request comments, use the [`pull_request_review_comment`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#pull_request_review_comment) or [`issue_comment`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#issue_comment) events instead. For information about the pull request review APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#pullrequest) in the GraphQL API documentation or [REST API endpoints for pull requests](https://docs.github.com/en/rest/pulls#reviews).

For example, you can run a workflow when a pull request review has been `edited` or `dismissed`.

```hljs yaml
on:
  pull_request_review:
    types: [edited, dismissed]

```

### [Running a workflow when a pull request is approved](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#running-a-workflow-when-a-pull-request-is-approved)

To run your workflow when a pull request has been approved, you can trigger your workflow with the `submitted` type of `pull_request_review` event, then check the review state with the `github.event.review.state` property. For example, this workflow will run whenever a pull request review is submitted, but the `approved` job will only run if the submitted review is an approving review:

```hljs yaml
on:
  pull_request_review:
    types: [submitted]

jobs:
  approved:
    if: github.event.review.state == 'approved'
    runs-on: ubuntu-latest
    steps:
      - run: echo "This PR was approved"

```

#### [Workflows in forked repositories](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#workflows-in-forked-repositories-1)

Workflows don't run in forked repositories by default. You must enable GitHub Actions in the **Actions** tab of the forked repository.

With the exception of `GITHUB_TOKEN`, secrets are not passed to the runner when a workflow is triggered from a forked repository. The `GITHUB_TOKEN` has read-only permissions in pull requests from forked repositories. For more information, see [Automatic token authentication](https://docs.github.com/en/actions/security-guides/automatic-token-authentication).

#### [Pull request events for forked repositories](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#pull-request-events-for-forked-repositories-1)

For pull requests from a forked repository to the base repository, GitHub sends the `pull_request`, `issue_comment`, `pull_request_review_comment`, `pull_request_review`, and `pull_request_target` events to the base repository. No pull request events occur on the forked repository.

When a first-time contributor submits a pull request to a public repository, a maintainer with write access may need to approve running workflows on the pull request. For more information, see [Approving workflow runs from public forks](https://docs.github.com/en/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks).

For pull requests from a forked repository to a private repository, workflows only run when they are enabled, see [Managing GitHub Actions settings for a repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#enabling-workflows-for-forks-of-private-repositories).

Note

Workflows triggered by Dependabot pull requests are treated as though they are from a forked repository, and are also subject to these restrictions.

## [`pull_request_review_comment`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#pull_request_review_comment)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`pull_request_review_comment`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#pull_request_review_comment) | \- `created`<br>\- `edited`<br>\- `deleted` | Last merge commit on the `GITHUB_REF` branch | PR merge branch `refs/pull/PULL_REQUEST_NUMBER/merge` |

Note

More than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#pull_request_review_comment). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).

Runs your workflow when a pull request review comment is modified. A pull request review comment is a comment on a pull request's diff. For activity related to pull request reviews or pull request comments, use the [`pull_request_review`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#pull_request_review) or [`issue_comment`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#issue_comment) events instead. For information about the pull request review comment APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#pullrequestreviewcomment) in the GraphQL API documentation or [REST API endpoints for pull requests](https://docs.github.com/en/rest/pulls#comments).

For example, you can run a workflow when a pull request review comment has been `created` or `deleted`.

```hljs yaml
on:
  pull_request_review_comment:
    types: [created, deleted]

```

#### [Workflows in forked repositories](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#workflows-in-forked-repositories-2)

Workflows don't run in forked repositories by default. You must enable GitHub Actions in the **Actions** tab of the forked repository.

With the exception of `GITHUB_TOKEN`, secrets are not passed to the runner when a workflow is triggered from a forked repository. The `GITHUB_TOKEN` has read-only permissions in pull requests from forked repositories. For more information, see [Automatic token authentication](https://docs.github.com/en/actions/security-guides/automatic-token-authentication).

#### [Pull request events for forked repositories](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#pull-request-events-for-forked-repositories-2)

For pull requests from a forked repository to the base repository, GitHub sends the `pull_request`, `issue_comment`, `pull_request_review_comment`, `pull_request_review`, and `pull_request_target` events to the base repository. No pull request events occur on the forked repository.

When a first-time contributor submits a pull request to a public repository, a maintainer with write access may need to approve running workflows on the pull request. For more information, see [Approving workflow runs from public forks](https://docs.github.com/en/actions/managing-workflow-runs/approving-workflow-runs-from-public-forks).

For pull requests from a forked repository to a private repository, workflows only run when they are enabled, see [Managing GitHub Actions settings for a repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#enabling-workflows-for-forks-of-private-repositories).

Note

Workflows triggered by Dependabot pull requests are treated as though they are from a forked repository, and are also subject to these restrictions.

## [`pull_request_target`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#pull_request_target)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`pull_request`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#pull_request) | \- `assigned`<br>\- `unassigned`<br>\- `labeled`<br>\- `unlabeled`<br>\- `opened`<br>\- `edited`<br>\- `closed`<br>\- `reopened`<br>\- `synchronize`<br>\- `converted_to_draft`<br>\- `ready_for_review`<br>\- `locked`<br>\- `unlocked`<br>\- `enqueued`<br>\- `dequeued`<br>\- `review_requested`<br>\- `review_request_removed`<br>\- `auto_merge_enabled`<br>\- `auto_merge_disabled` | Last commit on the PR base branch | PR base branch |

Note

More than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#pull_request). By default, a workflow only runs when a `pull_request_target` event's activity type is `opened`, `synchronize`, or `reopened`. To trigger workflows by different activity types, use the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).

Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated.

This event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the `pull_request` event does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request.

To ensure repository security, branches with names that match certain patterns (such as those which look similar to SHAs) may not trigger workflows with the `pull_request_target` event.

Warning

For workflows that are triggered by the `pull_request_target` event, the `GITHUB_TOKEN` is granted read/write repository permission unless the `permissions` key is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, see [Keeping your GitHub Actions and workflows secure: Preventing pwn requests](https://securitylab.github.com/research/github-actions-preventing-pwn-requests) on the GitHub Security Lab website.

For example, you can run a workflow when a pull request has been `assigned`, `opened`, `synchronize`, or `reopened`.

```hljs yaml
on:
  pull_request_target:
    types: [assigned, opened, synchronize, reopened]

```

### [Running your `pull_request_target` workflow based on the head or base branch of a pull request](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#running-your-pull_request_target-workflow-based-on-the-head-or-base-branch-of-a-pull-request)

You can use the `branches` or `branches-ignore` filter to configure your workflow to only run on pull requests that target specific branches. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpull_requestpull_request_targetbranchesbranches-ignore).

For example, this workflow will run when someone opens a pull request that targets a branch whose name starts with `releases/`:

```hljs yaml
on:
  pull_request_target:
    types:
      - opened
    branches:
      - 'releases/**'

```

Note

If you use both the `branches` filter and the `paths` filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript ( `.js`) file is opened on a branch whose name starts with `releases/`:

```hljs yaml
on:
  pull_request_target:
    types:
      - opened
    branches:
      - 'releases/**'
    paths:
      - '**.js'

```

To run a job based on the pull request's head branch name (as opposed to the pull request's base branch name), use the `github.head_ref` context in a conditional. For example, this workflow will run whenever a pull request is opened, but the `run_if` job will only execute if the head of the pull request is a branch whose name starts with `releases/`:

```hljs yaml
on:
  pull_request_target:
    types:
      - opened
jobs:
  run_if:
    if: startsWith(github.head_ref, 'releases/')
    runs-on: ubuntu-latest
    steps:
      - run: echo "The head of this PR starts with 'releases/'"

```

### [Running your `pull_request_target` workflow based on files changed in a pull request](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#running-your-pull_request_target-workflow-based-on-files-changed-in-a-pull-request)

You can use the `paths` or `paths-ignore` filter to configure your workflow to run when a pull request changes specific files. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).

For example, this workflow will run when a pull request includes a change to a JavaScript file ( `.js`):

```hljs yaml
on:
  pull_request_target:
    paths:
      - '**.js'

```

Note

If you use both the `branches` filter and the `paths` filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript ( `.js`) file is opened on a branch whose name starts with `releases/`:

```hljs yaml
on:
  pull_request_target:
    types:
      - opened
    branches:
      - 'releases/**'
    paths:
      - '**.js'

```

### [Running your `pull_request_target` workflow when a pull request merges](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#running-your-pull_request_target-workflow-when-a-pull-request-merges)

When a pull request merges, the pull request is automatically closed. To run a workflow when a pull request merges, use the `pull_request_target` `closed` event type along with a conditional that checks the `merged` value of the event. For example, the following workflow will run whenever a pull request closes. The `if_merged` job will only run if the pull request was also merged.

```hljs yaml
on:
  pull_request_target:
    types:
      - closed

jobs:
  if_merged:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
    - run: |
        echo The PR was merged

```

## [`push`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#push)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`push`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#push) | Not applicable | Tip commit pushed to the ref. When you delete a branch, the SHA in the workflow run (and its associated refs) reverts to the default branch of the repository. | Updated ref |

Note

The webhook payload available to GitHub Actions does not include the `added`, `removed`, and `modified` attributes in the `commit` object. You can retrieve the full commit object using the API. For information, see [Objects](https://docs.github.com/en/graphql/reference/objects#commit) in the GraphQL API documentation or [REST API endpoints for commits](https://docs.github.com/en/rest/commits#get-a-commit).

Note

Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once.

Runs your workflow when you push a commit or tag, or when you create a repository from a template.

For example, you can run a workflow when the `push` event occurs.

```hljs yaml
on:
  push

```

Note

When a `push` webhook event triggers a workflow run, the Actions UI's "pushed by" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the "pushed by" field will be the repository admin who verified the deploy key when it was added it to a repository.

### [Running your workflow only when a push to specific branches occurs](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#running-your-workflow-only-when-a-push-to-specific-branches-occurs)

You can use the `branches` or `branches-ignore` filter to configure your workflow to only run when specific branches are pushed. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushbranchestagsbranches-ignoretags-ignore).

For example, this workflow will run when someone pushes to `main` or to a branch that starts with `releases/`.

```hljs yaml
on:
  push:
    branches:
      - 'main'
      - 'releases/**'

```

Note

If you use both the `branches` filter and the `paths` filter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a push that includes a change to a JavaScript ( `.js`) file is made to a branch whose name starts with `releases/`:

```hljs yaml
on:
  push:
    branches:
      - 'releases/**'
    paths:
      - '**.js'

```

### [Running your workflow only when a push of specific tags occurs](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#running-your-workflow-only-when-a-push-of-specific-tags-occurs)

You can use the `tags` or `tags-ignore` filter to configure your workflow to only run when specific tags are pushed. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushbranchestagsbranches-ignoretags-ignore).

For example, this workflow will run when someone pushes a tag that starts with `v1.`.

```hljs yaml
on:
  push:
    tags:
      - v1.**

```

### [Running your workflow only when a push affects specific files](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#running-your-workflow-only-when-a-push-affects-specific-files)

You can use the `paths` or `paths-ignore` filter to configure your workflow to run when a push to specific files occurs. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).

For example, this workflow will run when someone pushes a change to a JavaScript file ( `.js`):

```hljs yaml
on:
  push:
    paths:
      - '**.js'

```

## [`registry_package`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#registry_package)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`registry_package`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#package) | \- `published`<br>\- `updated` | Commit of the published package | Branch or tag of the published package |

Note

More than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#registry_package). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Note

When pushing multi-architecture container images, this event occurs once per manifest, so you might observe your workflow triggering multiple times. To mitigate this, and only run your workflow job for the event that contains the actual image tag information, use a conditional:

```hljs yaml
jobs:
    job_name:
        if: $true

```

Runs your workflow when activity related to GitHub Packages occurs in your repository. For more information, see [GitHub Packages Documentation](https://docs.github.com/en/packages).

For example, you can run a workflow when a new package version has been `published`.

```hljs yaml
on:
  registry_package:
    types: [published]

```

## [`release`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#release)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`release`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#release) | \- `published`<br>\- `unpublished`<br>\- `created`<br>\- `edited`<br>\- `deleted`<br>\- `prereleased`<br> \- `released` | Last commit in the tagged release | Tag ref of release `refs/tags/<tag_name>` |

Note

More than one activity type triggers this event. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#release). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).

Note

Workflows are not triggered for the `created`, `edited`, or `deleted` activity types for draft releases. When you create your release through the GitHub UI, your release may automatically be saved as a draft.

Note

The `prereleased` type will not trigger for pre-releases published from draft releases, but the `published` type will trigger. If you want a workflow to run when stable _and_ pre-releases publish, subscribe to `published` instead of `released` and `prereleased`.

Runs your workflow when release activity in your repository occurs. For information about the release APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#release) in the GraphQL API documentation or [REST API endpoints for releases and release assets](https://docs.github.com/en/rest/releases) in the REST API documentation.

For example, you can run a workflow when a release has been `published`.

```hljs yaml
on:
  release:
    types: [published]

```

## [`repository_dispatch`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#repository_dispatch)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [repository\_dispatch](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#repository_dispatch) | Custom | Last commit on default branch | Default branch |

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

You can use the GitHub API to trigger a webhook event called [`repository_dispatch`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#repository_dispatch) when you want to trigger a workflow for activity that happens outside of GitHub. For more information, see [REST API endpoints for repositories](https://docs.github.com/en/rest/repos/repos#create-a-repository-dispatch-event).

When you make a request to create a `repository_dispatch` event, you must specify an `event_type` to describe the activity type. By default, all `repository_dispatch` activity types trigger a workflow to run. You can use the `types` keyword to limit your workflow to run when a specific `event_type` value is sent in the `repository_dispatch` webhook payload.

```hljs yaml
on:
  repository_dispatch:
    types: [test_result]

```

Note

The `event_type` value is limited to 100 characters.

Any data that you send through the `client_payload` parameter will be available in the `github.event` context in your workflow. For example, if you send this request body when you create a repository dispatch event:

```hljs json
{
  "event_type": "test_result",
  "client_payload": {
    "passed": false,
    "message": "Error: timeout"
  }
}

```

then you can access the payload in a workflow like this:

```hljs yaml
on:
  repository_dispatch:
    types: [test_result]

jobs:
  run_if_failure:
    if: ${{ !github.event.client_payload.passed }}
    runs-on: ubuntu-latest
    steps:
      - env:
          MESSAGE: ${{ github.event.client_payload.message }}
        run: echo $MESSAGE

```

Note

- The maximum number of top-level properties in `client_payload` is 10.
- The payload can contain a maximum of 65,535 characters.

## [`schedule`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#schedule)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| Not applicable | Not applicable | Last commit on default branch | Default branch |

Note

- The `schedule` event can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.

- This event will only trigger a workflow run if the workflow file is on the default branch.

- Scheduled workflows will only run on the default branch.

- In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days. For information on re-enabling a disabled workflow, see [Disabling and enabling a workflow](https://docs.github.com/en/enterprise-server/actions/using-workflows/disabling-and-enabling-a-workflow#enabling-a-workflow).

- For an enterprise with Enterprise Managed Users, scheduled workflows will not run if the last `actor` associated with the scheduled workflow has been deprovisioned (and therefore become suspended) by the Enterprise Managed User identity provider (IdP). However, if the last `actor` Enterprise Managed User has not been deprovisioned by the IdP, and has only been removed as a member from a given organization in the enterprise, scheduled workflows will still run with that user set as the `actor`. Similarly, for an enterprise without Enterprise Managed Users, removing a user from an organization will not prevent scheduled workflows which had that user as their `actor` from running. Essentially, triggering a scheduled workflow requires that the status of the `actor` user account associated with the workflow is currently active (i.e. not suspended or deleted). Thus, the _user account's_ status, in both Enterprise Managed User and non-Enterprise Managed User scenarios, is what's important, _not_ the user's _membership status_ in the organization where the scheduled workflow is located.

- Certain repository events change the `actor` associated with the workflow. For example, a user who changes the default branch of the repository, which changes the branch on which scheduled workflows run, becomes `actor` for those scheduled workflows.

- For a deactivated scheduled workflow, if a user with `write` permissions to the repository makes a commit that changes the `cron` schedule on the workflow, the workflow will be reactivated, and that user will become the `actor` associated with any workflow runs. Note that, in this situation, the workflow is not reactivated by any change to the workflow file; you must alter the `cron` value in the workflow and commit this change.

**Example:**


```hljs yaml
on:
    schedule:
    - cron: "15 4,5 * * *"   # <=== Change this value

```

The `schedule` event allows you to trigger a workflow at a scheduled time.

You can schedule a workflow to run at specific UTC times using [POSIX cron syntax](https://pubs.opengroup.org/onlinepubs/9699919799/utilities/crontab.html#tag_20_25_07). Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes.

This example triggers the workflow every day at 5:30 and 17:30 UTC:

```hljs yaml
on:
  schedule:
    # * is a special character in YAML so you have to quote this string
    - cron:  '30 5,17 * * *'

```

A single workflow can be triggered by multiple `schedule` events. You can access the schedule event that triggered the workflow through the `github.event.schedule` context. This example triggers the workflow to run at 5:30 UTC every Monday-Thursday, but skips the `Not on Monday or Wednesday` step on Monday and Wednesday.

```hljs yaml
on:
  schedule:
    - cron: '30 5 * * 1,3'
    - cron: '30 5 * * 2,4'

jobs:
  test_schedule:
    runs-on: ubuntu-latest
    steps:
      - name: Not on Monday or Wednesday
        if: github.event.schedule != '30 5 * * 1,3'
        run: echo "This step will be skipped on Monday and Wednesday"
      - name: Every time
        run: echo "This step will always run"

```

Cron syntax has five fields separated by a space, and each field represents a unit of time.

```hljs text
 minute (0 - 59)
  hour (0 - 23)
   day of the month (1 - 31)
    month (1 - 12 or JAN-DEC)
     day of the week (0 - 6 or SUN-SAT)
    
    
    
* * * * *

```

You can use these operators in any of the five fields:

| Operator | Description | Example |
| --- | --- | --- |
| \* | Any value | `15 * * * *` runs at every minute 15 of every hour of every day. |
| , | Value list separator | `2,10 4,5 * * *` runs at minute 2 and 10 of the 4th and 5th hour of every day. |
| - | Range of values | `30 4-6 * * *` runs at minute 30 of the 4th, 5th, and 6th hour. |
| / | Step values | `20/15 * * * *` runs every 15 minutes starting from minute 20 through 59 (minutes 20, 35, and 50). |

Note

GitHub Actions does not support the non-standard syntax `@yearly`, `@monthly`, `@weekly`, `@daily`, `@hourly`, and `@reboot`.

You can use [crontab guru](https://crontab.guru/) to help generate your cron syntax and confirm what time it will run. To help you get started, there is also a list of [crontab guru examples](https://crontab.guru/examples.html).

Notifications for scheduled workflows are sent to the user who last modified the cron syntax in the workflow file. For more information, see [Notifications for workflow runs](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/notifications-for-workflow-runs).

## [`status`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#status)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`status`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#status) | Not applicable | Last commit on default branch | Default branch |

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when the status of a Git commit changes. For example, commits can be marked as `error`, `failure`, `pending`, or `success`. If you want to provide more details about the status change, you may want to use the [`check_run`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#check_run) event. For information about the commit status APIs, see [Objects](https://docs.github.com/en/graphql/reference/objects#status) in the GraphQL API documentation or [REST API endpoints for commits](https://docs.github.com/en/rest/commits#commit-statuses).

For example, you can run a workflow when the `status` event occurs.

```hljs yaml
on:
  status

```

If you want to run a job in your workflow based on the new commit state, you can use the `github.event.state` context. For example, the following workflow triggers when a commit status changes, but the `if_error_or_failure` job only runs if the new commit state is `error` or `failure`.

```hljs yaml
on:
  status
jobs:
  if_error_or_failure:
    runs-on: ubuntu-latest
    if: >-
      github.event.state == 'error' ||
      github.event.state == 'failure'
    steps:
      - env:
          DESCRIPTION: ${{ github.event.description }}
        run: |
          echo The status is error or failed: $DESCRIPTION

```

## [`watch`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#watch)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`watch`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#watch) | \- `started` | Last commit on default branch | Default branch |

Note

More than one activity type triggers this event. Although only the `started` activity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#watch). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Runs your workflow when the workflow's repository is starred. For information about the pull request APIs, see [Mutations](https://docs.github.com/en/graphql/reference/mutations#addstar) in the GraphQL API documentation or [REST API endpoints for starring](https://docs.github.com/en/rest/activity/starring).

For example, you can run a workflow when someone stars a repository, which is the `started` activity type for a watch event.

```hljs yaml
on:
  watch:
    types: [started]

```

## [`workflow_call`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#workflow_call)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| Same as the caller workflow | Not applicable | Same as the caller workflow | Same as the caller workflow |

`workflow_call` is used to indicate that a workflow can be called by another workflow. When a workflow is triggered with the `workflow_call` event, the event payload in the called workflow is the same event payload from the calling workflow. For more information see, [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows).

The example below only runs the workflow when it's called from another workflow:

```hljs yaml
on: workflow_call

```

## [`workflow_dispatch`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#workflow_dispatch)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [workflow\_dispatch](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#workflow_dispatch) | Not applicable | Last commit on the `GITHUB_REF` branch or tag | Branch or tag that received dispatch |

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

To enable a workflow to be triggered manually, you need to configure the `workflow_dispatch` event. You can manually trigger a workflow run using the GitHub API, GitHub CLI, or the GitHub UI. For more information, see [Manually running a workflow](https://docs.github.com/en/actions/managing-workflow-runs/manually-running-a-workflow).

```hljs yaml
on: workflow_dispatch

```

### [Providing inputs](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#providing-inputs)

You can configure custom-defined input properties, default input values, and required inputs for the event directly in your workflow. When you trigger the event, you can provide the `ref` and any `inputs`. When the workflow runs, you can access the input values in the `inputs` context. For more information, see [Contexts reference](https://docs.github.com/en/actions/learn-github-actions/contexts).

Note

- The workflow will also receive the inputs in the `github.event.inputs` context. The information in the `inputs` context and `github.event.inputs` context is identical except that the `inputs` context preserves Boolean values as Booleans instead of converting them to strings. The `choice` type resolves to a string and is a single selectable option.
- The maximum number of top-level properties for `inputs` is 10.
- The maximum payload for `inputs` is 65,535 characters.

This example defines inputs called `logLevel`, `tags`, and `environment`. You pass values for these inputs to the workflow when you run it. This workflow then prints the values to the log, using the `inputs.logLevel`, `inputs.tags`, and `inputs.environment` context properties.

```hljs yaml
on:
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: true
        default: 'warning'
        type: choice
        options:
        - info
        - warning
        - debug
      tags:
        description: 'Test scenario tags'
        required: false
        type: boolean
      environment:
        description: 'Environment to run tests against'
        type: environment
        required: true

jobs:
  log-the-inputs:
    runs-on: ubuntu-latest
    steps:
      - run: |
          echo "Log level: $LEVEL"
          echo "Tags: $TAGS"
          echo "Environment: $ENVIRONMENT"
        env:
          LEVEL: ${{ inputs.logLevel }}
          TAGS: ${{ inputs.tags }}
          ENVIRONMENT: ${{ inputs.environment }}

```

If you run this workflow from a browser you must enter values for the required inputs manually before the workflow will run.

![Screenshot of a list of workflow runs. A dropdown menu, labeled "Run workflow" and expanded to show input fields, is outlined in dark orange.](https://docs.github.com/assets/cb-78157/images/help/actions/workflow-dispatch-inputs.png)

You can also pass inputs when you run a workflow from a script, or by using GitHub CLI. For example:

```hljs shell
gh workflow run run-tests.yml -f logLevel=warning -f tags=false -f environment=staging

```

For more information, see the GitHub CLI information in [Manually running a workflow](https://docs.github.com/en/actions/managing-workflow-runs/manually-running-a-workflow).

## [`workflow_run`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#workflow_run)

| Webhook event payload | Activity types | `GITHUB_SHA` | `GITHUB_REF` |
| --- | --- | --- | --- |
| [`workflow_run`](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#workflow_run) | \- `completed`<br>\- `requested`<br>\- `in_progress` | Last commit on default branch | Default branch |

Note

More than one activity type triggers this event. The `requested` activity type does not occur when a workflow is re-run. For information about each activity type, see [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#workflow_run). By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using the `types` keyword. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onevent_nametypes).

Note

This event will only trigger a workflow run if the workflow file exists on the default branch.

Note

You can't use `workflow_run` to chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (named `B` to `F`) to run sequentially after an initial workflow `A` has run (that is: `A`  `B`  `C`  `D`  `E`  `F`), workflows `E` and `F` will not be run.

This event occurs when a workflow run is requested or completed. It allows you to execute a workflow based on execution or completion of another workflow. The workflow started by the `workflow_run` event is able to access secrets and write tokens, even if the previous workflow was not. This is useful in cases where the previous workflow is intentionally not privileged, but you need to take a privileged action in a later workflow.

In this example, a workflow is configured to run after the separate "Run Tests" workflow completes.

```hljs yaml
on:
  workflow_run:
    workflows: [Run Tests]
    types:
      - completed

```

If you specify multiple `workflows` for the `workflow_run` event, only one of the workflows needs to run. For example, a workflow with the following trigger will run whenever the "Staging" workflow or the "Lab" workflow completes.

```hljs yaml
on:
  workflow_run:
    workflows: [Staging, Lab]
    types:
      - completed

```

### [Running a workflow based on the conclusion of another workflow](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#running-a-workflow-based-on-the-conclusion-of-another-workflow)

A workflow run is triggered regardless of the conclusion of the previous workflow. If you want to run a job or step based on the result of the triggering workflow, you can use a conditional with the `github.event.workflow_run.conclusion` property. For example, this workflow will run whenever a workflow named "Build" completes, but the `on-success` job will only run if the "Build" workflow succeeded, and the `on-failure` job will only run if the "Build" workflow failed:

```hljs yaml
on:
  workflow_run:
    workflows: [Build]
    types: [completed]

jobs:
  on-success:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    steps:
      - run: echo 'The triggering workflow passed'
  on-failure:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    steps:
      - run: echo 'The triggering workflow failed'

```

### [Limiting your workflow to run based on branches](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#limiting-your-workflow-to-run-based-on-branches)

You can use the `branches` or `branches-ignore` filter to specify what branches the triggering workflow must run on in order to trigger your workflow. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onworkflow_runbranchesbranches-ignore). For example, a workflow with the following trigger will only run when the workflow named `Build` runs on a branch named `canary`.

```hljs yaml
on:
  workflow_run:
    workflows: [Build]
    types: [requested]
    branches: [canary]

```

### [Using data from the triggering workflow](https://docs.github.com/en/actions/reference/events-that-trigger-workflows\#using-data-from-the-triggering-workflow)

You can access the [`workflow_run` event payload](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#workflow_run) that corresponds to the workflow that triggered your workflow. For example, if your triggering workflow generates artifacts, a workflow triggered with the `workflow_run` event can access these artifacts.

The following workflow uploads data as an artifact. (In this simplified example, the data is the pull request number.)

```hljs yaml
name: Upload data

on:
  pull_request:

jobs:
  upload:
    runs-on: ubuntu-latest

    steps:
      - name: Save PR number
        env:
          PR_NUMBER: ${{ github.event.number }}
        run: |
          mkdir -p ./pr
          echo $PR_NUMBER > ./pr/pr_number
      - uses: actions/upload-artifact@v4
        with:
          name: pr_number
          path: pr/

```

When a run of the above workflow completes, it triggers a run of the following workflow. The following workflow uses the `github.event.workflow_run` context and the GitHub REST API to download the artifact that was uploaded by the above workflow, unzips the downloaded artifact, and comments on the pull request whose number was uploaded as an artifact.

```hljs yaml
name: Use the data

on:
  workflow_run:
    workflows: [Upload data]
    types:
      - completed

jobs:
  download:
    runs-on: ubuntu-latest
    steps:
      - name: 'Download artifact'
        uses: actions/github-script@v7
        with:
          script: |
            let allArtifacts = await github.rest.actions.listWorkflowRunArtifacts({
               owner: context.repo.owner,
               repo: context.repo.repo,
               run_id: context.payload.workflow_run.id,
            });
            let matchArtifact = allArtifacts.data.artifacts.filter((artifact) => {
              return artifact.name == "pr_number"
            })[0];
            let download = await github.rest.actions.downloadArtifact({
               owner: context.repo.owner,
               repo: context.repo.repo,
               artifact_id: matchArtifact.id,
               archive_format: 'zip',
            });
            const fs = require('fs');
            const path = require('path');
            const temp = '${{ runner.temp }}/artifacts';
            if (!fs.existsSync(temp)){
              fs.mkdirSync(temp);
            }
            fs.writeFileSync(path.join(temp, 'pr_number.zip'), Buffer.from(download.data));

      - name: 'Unzip artifact'
        run: unzip pr_number.zip -d "${{ runner.temp }}/artifacts"

      - name: 'Comment on PR'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const temp = '${{ runner.temp }}/artifacts';
            const issue_number = Number(fs.readFileSync(path.join(temp, 'pr_number')));
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue_number,
              body: 'Thank you for the PR!'
            });

```

---


## 3. Using jobs in a workflow {#section-3}

*Source: [https://docs.github.com/en/actions/using-jobs/using-jobs-in-a-workflow](https://docs.github.com/en/actions/using-jobs/using-jobs-in-a-workflow)*


# Using jobs in a workflow

Use workflows to run multiple jobs.

## In this article

## [Overview](https://docs.github.com/en/actions/how-tos/writing-workflows/choosing-what-your-workflow-does/using-jobs-in-a-workflow\#overview)

A workflow run is made up of one or more `jobs`, which run in parallel by default. To run jobs sequentially, you can define dependencies on other jobs using the `jobs.<job_id>.needs` keyword.

Each job runs in a runner environment specified by `runs-on`.

You can run an unlimited number of jobs as long as you are within the workflow usage limits. For more information, see [Usage limits, billing, and administration](https://docs.github.com/en/actions/learn-github-actions/usage-limits-billing-and-administration) for GitHub-hosted runners and [Usage limits for self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/usage-limits-for-self-hosted-runners) for self-hosted runner usage limits.

If you need to find the unique identifier of a job running in a workflow run, you can use the GitHub API. For more information, see [REST API endpoints for GitHub Actions](https://docs.github.com/en/rest/actions#workflow-jobs).

## [Setting an ID for a job](https://docs.github.com/en/actions/how-tos/writing-workflows/choosing-what-your-workflow-does/using-jobs-in-a-workflow\#setting-an-id-for-a-job)

Use `jobs.<job_id>` to give your job a unique identifier. The key `job_id` is a string and its value is a map of the job's configuration data. You must replace `<job_id>` with a string that is unique to the `jobs` object. The `<job_id>` must start with a letter or `_` and contain only alphanumeric characters, `-`, or `_`.

### [Example: Creating jobs](https://docs.github.com/en/actions/how-tos/writing-workflows/choosing-what-your-workflow-does/using-jobs-in-a-workflow\#example-creating-jobs)

In this example, two jobs have been created, and their `job_id` values are `my_first_job` and `my_second_job`.

```hljs yaml
jobs:
  my_first_job:
    name: My first job
  my_second_job:
    name: My second job

```

## [Setting a name for a job](https://docs.github.com/en/actions/how-tos/writing-workflows/choosing-what-your-workflow-does/using-jobs-in-a-workflow\#setting-a-name-for-a-job)

Use `jobs.<job_id>.name` to set a name for the job, which is displayed in the GitHub UI.

## [Defining prerequisite jobs](https://docs.github.com/en/actions/how-tos/writing-workflows/choosing-what-your-workflow-does/using-jobs-in-a-workflow\#defining-prerequisite-jobs)

Use `jobs.<job_id>.needs` to identify any jobs that must complete successfully before this job will run. It can be a string or array of strings. If a job fails or is skipped, all jobs that need it are skipped unless the jobs use a conditional expression that causes the job to continue. If a run contains a series of jobs that need each other, a failure or skip applies to all jobs in the dependency chain from the point of failure or skip onwards. If you would like a job to run even if a job it is dependent on did not succeed, use the `always()` conditional expression in `jobs.<job_id>.if`.

### [Example: Requiring successful dependent jobs](https://docs.github.com/en/actions/how-tos/writing-workflows/choosing-what-your-workflow-does/using-jobs-in-a-workflow\#example-requiring-successful-dependent-jobs)

```hljs yaml
jobs:
  job1:
  job2:
    needs: job1
  job3:
    needs: [job1, job2]

```

In this example, `job1` must complete successfully before `job2` begins, and `job3` waits for both `job1` and `job2` to complete.

The jobs in this example run sequentially:

1. `job1`
2. `job2`
3. `job3`

### [Example: Not requiring successful dependent jobs](https://docs.github.com/en/actions/how-tos/writing-workflows/choosing-what-your-workflow-does/using-jobs-in-a-workflow\#example-not-requiring-successful-dependent-jobs)

```hljs yaml
jobs:
  job1:
  job2:
    needs: job1
  job3:
    if: ${{ always() }}
    needs: [job1, job2]

```

In this example, `job3` uses the `always()` conditional expression so that it always runs after `job1` and `job2` have completed, regardless of whether they were successful. For more information, see [Evaluate expressions in workflows and actions](https://docs.github.com/en/actions/learn-github-actions/expressions#status-check-functions).

---


## 4. Reusing workflows {#section-4}

*Source: [https://docs.github.com/en/actions/using-workflows/reusing-workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows)*


# Reusing workflows

Learn how to avoid duplication when creating a workflow by reusing existing workflows.

## In this article

## [Overview](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#overview)

Rather than copying and pasting from one workflow to another, you can make workflows reusable. You and anyone with access to the reusable workflow can then call the reusable workflow from another workflow.

Reusing workflows avoids duplication. This makes workflows easier to maintain and allows you to create new workflows more quickly by building on the work of others, just as you do with actions. Workflow reuse also promotes best practice by helping you to use workflows that are well designed, have already been tested, and have been proven to be effective. Your organization can build up a library of reusable workflows that can be centrally maintained.

The diagram below shows an in-progress workflow run that uses a reusable workflow.

- After each of three build jobs on the left of the diagram completes successfully, a dependent job called "Deploy" is run.
- The "Deploy" job calls a reusable workflow that contains three jobs: "Staging", "Review", and "Production."
- The "Production" deployment job only runs after the "Staging" job has completed successfully.
- When a job targets an environment, the workflow run displays a progress bar that shows the number of steps in the job. In the diagram below, the "Production" job contains 8 steps, with step 6 currently being processed.
- Using a reusable workflow to run deployment jobs allows you to run those jobs for each build without duplicating code in workflows.

![Diagram of a workflow calling a reusable workflow.](https://docs.github.com/assets/cb-34427/images/help/actions/reusable-workflows-ci-cd.png)

A workflow that uses another workflow is referred to as a "caller" workflow. The reusable workflow is a "called" workflow. One caller workflow can use multiple called workflows. Each called workflow is referenced in a single line. The result is that the caller workflow file may contain just a few lines of YAML, but may perform a large number of tasks when it's run. When you reuse a workflow, the entire called workflow is used, just as if it was part of the caller workflow.

If you reuse a workflow from a different repository, any actions in the called workflow run as if they were part of the caller workflow. For example, if the called workflow uses `actions/checkout`, the action checks out the contents of the repository that hosts the caller workflow, not the called workflow.

When a reusable workflow is triggered by a caller workflow, the `github` context is always associated with the caller workflow. The called workflow is automatically granted access to `github.token` and `secrets.GITHUB_TOKEN`. For more information about the `github` context, see [Contexts reference](https://docs.github.com/en/actions/learn-github-actions/contexts#github-context).

You can view the reused workflows referenced in your GitHub Actions workflows as dependencies in the dependency graph of the repository containing your workflows. For more information, see  [About the dependency graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph).

### [Reusable workflows and composite actions](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#reusable-workflows-and-composite-actions)

Reusable workflows and composite actions both help you to avoid duplication. Whereas reusable workflows allow you to reuse an entire workflow, with multiple jobs and steps, composite actions combine multiple steps that you can then run within a job step, just like any other action. For more information, see [Avoiding duplication](https://docs.github.com/en/actions/using-workflows/avoiding-duplication).

### [Reusable workflows and workflow templates](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#reusable-workflows-and-workflow-templates)

Workflow templates allow everyone in your organization who has permission to create workflows to do so more quickly and easily. When people create a new workflow, they can choose a workflow template and some or all of the work of writing the workflow will be done for them. Within a workflow template, you can also reference reusable workflows to make it easy for people to benefit from reusing centrally managed workflow code. If you use a commit SHA when referencing the reusable workflow, you can ensure that everyone who reuses that workflow will always be using the same YAML code. However, if you reference a reusable workflow by a tag or branch, be sure that you can trust that version of the workflow. For more information, see [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#reusing-third-party-workflows).

For more information, see [Creating workflow templates for your organization](https://docs.github.com/en/actions/using-workflows/creating-starter-workflows-for-your-organization).

## [Access to reusable workflows](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#access-to-reusable-workflows)

A reusable workflow can be used by another workflow if any of the following is true:

- Both workflows are in the same repository.
- The called workflow is stored in a public repository, and your organization allows you to use public reusable workflows.
- The called workflow is stored in a private repository and the settings for that repository allow it to be accessed. For more information, see [Sharing actions and workflows with your organization](https://docs.github.com/en/actions/creating-actions/sharing-actions-and-workflows-with-your-organization) and [Sharing actions and workflows from your private repository](https://docs.github.com/en/actions/creating-actions/sharing-actions-and-workflows-from-your-private-repository).

The following table shows the accessibility of reusable workflows to a caller workflow, depending on the visibility of the host repository.

| Caller repository | Accessible workflows repositories |
| --- | --- |
| `private` | `private` and `public` |
| `public` | `public` |

The **Actions permissions** on the callers repository's Actions settings page must be configured to allow the use of actions and reusable workflows - see [Managing GitHub Actions settings for a repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-select-actions-and-reusable-workflows-to-run).

For private repositories, the **Access** policy on the Actions settings page of the called workflow's repository must be explicitly configured to allow access from repositories containing caller workflows - see [Managing GitHub Actions settings for a repository](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/enabling-features-for-your-repository/managing-github-actions-settings-for-a-repository#allowing-access-to-components-in-a-private-repository).

Note

To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail.

## [Using runners](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#using-runners)

### [Using GitHub-hosted runners](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#using-github-hosted-runners)

The assignment of GitHub-hosted runners is always evaluated using only the caller's context. Billing for GitHub-hosted runners is always associated with the caller. The caller workflow cannot use GitHub-hosted runners from the called repository. For more information, see [About GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners).

### [Using self-hosted runners](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#using-self-hosted-runners)

Called workflows that are owned by the same user or organization as the caller workflow can access self-hosted runners from the caller's context. This means that a called workflow can access self-hosted runners that are:

- In the caller repository
- In the caller repository's organization, provided that the runner has been made available to the caller repository

## [Limitations](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#limitations)

- You can connect up to four levels of workflows. For more information, see [Nesting reusable workflows](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows#nesting-reusable-workflows).

- You can call a maximum of 20 unique reusable workflows from a single workflow file. This limit includes any trees of nested reusable workflows that may be called starting from your top-level caller workflow file.

For example, _top-level-caller-workflow.yml_  _called-workflow-1.yml_  _called-workflow-2.yml_ counts as 2 reusable workflows.

- Any environment variables set in an `env` context defined at the workflow level in the caller workflow are not propagated to the called workflow. For more information, see [Store information in variables](https://docs.github.com/en/actions/learn-github-actions/variables) and [Contexts reference](https://docs.github.com/en/actions/learn-github-actions/contexts#env-context).

- Similarly, environment variables set in the `env` context, defined in the called workflow, are not accessible in the `env` context of the caller workflow. Instead, you must use outputs of the reusable workflow. For more information, see [Using outputs from a reusable workflow](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows#using-outputs-from-a-reusable-workflow).

- To reuse variables in multiple workflows, set them at the organization, repository, or environment levels and reference them using the `vars` context. For more information see [Store information in variables](https://docs.github.com/en/actions/learn-github-actions/variables) and [Contexts reference](https://docs.github.com/en/actions/learn-github-actions/contexts#vars-context).

- Reusable workflows are called directly within a job, and not from within a job step. You cannot, therefore, use `GITHUB_ENV` to pass values to job steps in the caller workflow.


## [Creating a reusable workflow](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#creating-a-reusable-workflow)

Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the `.github/workflows` directory of a repository. Subdirectories of the `workflows` directory are not supported.

For a workflow to be reusable, the values for `on` must include `workflow_call`:

```hljs yaml
on:
  workflow_call:

```

### [Using inputs and secrets in a reusable workflow](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#using-inputs-and-secrets-in-a-reusable-workflow)

You can define inputs and secrets, which can be passed from the caller workflow and then used within the called workflow. There are three stages to using an input or a secret in a reusable workflow.

1. In the reusable workflow, use the `inputs` and `secrets` keywords to define inputs or secrets that will be passed from a caller workflow.


```hljs yaml
on:
     workflow_call:
       inputs:
         config-path:
           required: true
           type: string
       secrets:
         personal_access_token:
           required: true

```


For details of the syntax for defining inputs and secrets, see [`on.workflow_call.inputs`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onworkflow_callinputs) and [`on.workflow_call.secrets`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onworkflow_callsecrets).

2. In the reusable workflow, reference the input or secret that you defined in the `on` key in the previous step.



Note




If the secrets are inherited by using `secrets: inherit` in the calling workflow, you can reference them even if they are not explicitly defined in the `on` key. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idsecretsinherit).




```hljs yaml
jobs:
     reusable_workflow_job:
       runs-on: ubuntu-latest
       steps:
    - uses: actions/labeler@v4
      with:
        repo-token: ${{ secrets.personal_access_token }}
        configuration-path: ${{ inputs.config-path }}

```

In the example above, `personal_access_token` is a secret that's defined at the repository or organization level.

Warning

Environment secrets cannot be passed from the caller workflow as `on.workflow_call` does not support the `environment` keyword. If you include `environment` in the reusable workflow at the job level, the environment secret will be used, and not the secret passed from the caller workflow. For more information, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment#environment-secrets) and [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions#onworkflow_call).

3. Pass the input or secret from the caller workflow.

To pass named inputs to a called workflow, use the `with` keyword in a job. Use the `secrets` keyword to pass named secrets. For inputs, the data type of the input value must match the type specified in the called workflow (either boolean, number, or string).


```hljs yaml
jobs:
     call-workflow-passing-data:
       uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
       with:
         config-path: .github/labeler.yml
       secrets:
         personal_access_token: ${{ secrets.token }}

```


Workflows that call reusable workflows in the same organization or enterprise can use the `inherit` keyword to implicitly pass the secrets.


```hljs yaml
jobs:
     call-workflow-passing-data:
       uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
       with:
         config-path: .github/labeler.yml
       secrets: inherit

```


### [Example reusable workflow](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#example-reusable-workflow)

This reusable workflow file named `workflow-B.yml` (we'll refer to this later in the [example caller workflow](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows#example-caller-workflow)) takes an input string and a secret from the caller workflow and uses them in an action.

```hljs yaml
name: Reusable workflow example

on:
workflow_call:
    inputs:
      config-path:
        required: true
        type: string
    secrets:
      token:
        required: true

jobs:
triage:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/labeler@v4
      with:
        repo-token: ${{ secrets.token }}
        configuration-path: ${{ inputs.config-path }}

```

## [Calling a reusable workflow](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#calling-a-reusable-workflow)

You call a reusable workflow by using the `uses` keyword. Unlike when you are using actions within a workflow, you call reusable workflows directly within a job, and not from within job steps.

[`jobs.<job_id>.uses`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_iduses)

You reference reusable workflow files using one of the following syntaxes:

- `{owner}/{repo}/.github/workflows/{filename}@{ref}` for reusable workflows in public and private repositories.
- `./.github/workflows/{filename}` for reusable workflows in the same repository.

In the first option, `{ref}` can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, see [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#reusing-third-party-workflows).

If you use the second syntax option (without `{owner}/{repo}` and `@{ref}`) the called workflow is from the same commit as the caller workflow. Ref prefixes such as `refs/heads` and `refs/tags` are not allowed. You cannot use contexts or expressions in this keyword.

You can call multiple workflows, referencing each in a separate job.

```hljs yaml
jobs:
call-workflow-1-in-local-repo:
    uses: octo-org/this-repo/.github/workflows/workflow-1.yml@172239021f7ba04fe7327647b213799853a9eb89
call-workflow-2-in-local-repo:
    uses: ./.github/workflows/workflow-2.yml
call-workflow-in-another-repo:
    uses: octo-org/another-repo/.github/workflows/workflow.yml@v1

```

### [Passing inputs and secrets to a reusable workflow](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#passing-inputs-and-secrets-to-a-reusable-workflow)

To pass named inputs to a called workflow, use the `with` keyword in a job. Use the `secrets` keyword to pass named secrets. For inputs, the data type of the input value must match the type specified in the called workflow (either boolean, number, or string).

```hljs yaml
jobs:
call-workflow-passing-data:
    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
    with:
      config-path: .github/labeler.yml
    secrets:
      personal_access_token: ${{ secrets.token }}

```

Workflows that call reusable workflows in the same organization or enterprise can use the `inherit` keyword to implicitly pass the secrets.

```hljs yaml
jobs:
call-workflow-passing-data:
    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main
    with:
      config-path: .github/labeler.yml
    secrets: inherit

```

### [Using a matrix strategy with a reusable workflow](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#using-a-matrix-strategy-with-a-reusable-workflow)

Jobs using the matrix strategy can call a reusable workflow.

A matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. For example, you can use a matrix strategy to pass different inputs to a reusable workflow. For more information about matrices, see [Running variations of jobs in a workflow](https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs).

This example job below calls a reusable workflow and references the matrix context by defining the variable `target` with the values `[dev, stage, prod]`. It will run three jobs, one for each value in the variable.

```hljs yaml
jobs:
ReusableMatrixJobForDeployment:
    strategy:
      matrix:
        target: [dev, stage, prod]
    uses: octocat/octo-repo/.github/workflows/deployment.yml@main
    with:
      target: ${{ matrix.target }}

```

### [Supported keywords for jobs that call a reusable workflow](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#supported-keywords-for-jobs-that-call-a-reusable-workflow)

When you call a reusable workflow, you can only use the following keywords in the job containing the call:

- [`jobs.<job_id>.name`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idname)

- [`jobs.<job_id>.uses`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_iduses)

- [`jobs.<job_id>.with`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idwith)

- [`jobs.<job_id>.with.<input_id>`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idwithinput_id)

- [`jobs.<job_id>.secrets`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idsecrets)

- [`jobs.<job_id>.secrets.<secret_id>`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idsecretssecret_id)

- [`jobs.<job_id>.secrets.inherit`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idsecretsinherit)

- [`jobs.<job_id>.strategy`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstrategy)

- [`jobs.<job_id>.needs`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idneeds)

- [`jobs.<job_id>.if`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idif)

- [`jobs.<job_id>.concurrency`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idconcurrency)

- [`jobs.<job_id>.permissions`](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idpermissions)



Note







- If `jobs.<job_id>.permissions` is not specified in the calling job, the called workflow will have the default permissions for the `GITHUB_TOKEN`. For more information, see [Automatic token authentication](https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token).
- The `GITHUB_TOKEN` permissions passed from the caller workflow can be only downgraded (not elevated) by the called workflow.
- If you use `jobs.<job_id>.concurrency.cancel-in-progress: true`, don't use the same value for `jobs.<job_id>.concurrency.group` in the called and caller workflows as this will cause the workflow that's already running to be cancelled. A called workflow uses the name of its caller workflow in ${{ github.workflow }}, so using this context as the value of `jobs.<job_id>.concurrency.group` in both caller and called workflows will cause the caller workflow to be cancelled when the called workflow runs.

### [Example caller workflow](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#example-caller-workflow)

This workflow file calls two workflow files. The second of these, `workflow-B.yml` (shown in the [example reusable workflow](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows#example-reusable-workflow)), is passed an input ( `config-path`) and a secret ( `token`).

```hljs yaml
name: Call a reusable workflow

on:
pull_request:
    branches:
      - main

jobs:
call-workflow:
    uses: octo-org/example-repo/.github/workflows/workflow-A.yml@v1

call-workflow-passing-data:
    permissions:
      contents: read
      pull-requests: write
    uses: octo-org/example-repo/.github/workflows/workflow-B.yml@main
    with:
      config-path: .github/labeler.yml
    secrets:
      token: ${{ secrets.GITHUB_TOKEN }}

```

## [Nesting reusable workflows](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#nesting-reusable-workflows)

You can connect a maximum of four levels of workflows - that is, the top-level caller workflow and up to three levels of reusable workflows. For example: _caller-workflow.yml_  _called-workflow-1.yml_  _called-workflow-2.yml_  _called-workflow-3.yml_. Loops in the workflow tree are not permitted.

From within a reusable workflow you can call another reusable workflow.

```hljs yaml
name: Reusable workflow

on:
workflow_call:

jobs:
call-another-reusable:
    uses: octo-org/example-repo/.github/workflows/another-reusable.yml@v1

```

### [Passing secrets to nested workflows](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#passing-secrets-to-nested-workflows)

You can use `jobs.<job_id>.secrets` in a calling workflow to pass named secrets to a directly called workflow. Alternatively, you can use `jobs.<job_id>.secrets.inherit` to pass all of the calling workflow's secrets to a directly called workflow. For more information, see the section [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows#passing-inputs-and-secrets-to-a-reusable-workflow) above, and the reference article [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idsecretsinherit). Secrets are only passed to directly called workflow, so in the workflow chain A > B > C, workflow C will only receive secrets from A if they have been passed from A to B, and then from B to C.

In the following example, workflow A passes all of its secrets to workflow B, by using the `inherit` keyword, but workflow B only passes one secret to workflow C. Any of the other secrets passed to workflow B are not available to workflow C.

```hljs yaml
jobs:
workflowA-calls-workflowB:
    uses: octo-org/example-repo/.github/workflows/B.yml@main
    secrets: inherit # pass all secrets

```

```hljs yaml
jobs:
workflowB-calls-workflowC:
    uses: different-org/example-repo/.github/workflows/C.yml@main
    secrets:
      repo-token: ${{ secrets.personal_access_token }} # pass just this secret

```

### [Access and permissions](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#access-and-permissions)

A workflow that contains nested reusable workflows will fail if any of the nested workflows is inaccessible to the initial caller workflow. For more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows#access-to-reusable-workflows).

`GITHUB_TOKEN` permissions can only be the same or more restrictive in nested workflows. For example, in the workflow chain A > B > C, if workflow A has `package: read` token permission, then B and C cannot have `package: write` permission. For more information, see [Automatic token authentication](https://docs.github.com/en/actions/security-guides/automatic-token-authentication).

For information on how to use the API to determine which workflow files were involved in a particular workflow run, see [Monitoring which workflows are being used](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows#monitoring-which-workflows-are-being-used).

## [Using outputs from a reusable workflow](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#using-outputs-from-a-reusable-workflow)

A reusable workflow may generate data that you want to use in the caller workflow. To use these outputs, you must specify them as the outputs of the reusable workflow.

If a reusable workflow that sets an output is executed with a matrix strategy, the output will be the output set by the last successful completing reusable workflow of the matrix which actually sets a value.
That means if the last successful completing reusable workflow sets an empty string for its output, and the second last successful completing reusable workflow sets an actual value for its output, the output will contain the value of the second last completing reusable workflow.

The following reusable workflow has a single job containing two steps. In each of these steps we set a single word as the output: "hello" and "world." In the `outputs` section of the job, we map these step outputs to job outputs called: `output1` and `output2`. In the `on.workflow_call.outputs` section we then define two outputs for the workflow itself, one called `firstword` which we map to `output1`, and one called `secondword` which we map to `output2`.

The `value` must be set to the value of a job-level output within the called workflow. Step-level outputs must first be mapped to job-level outputs as shown below.

For more information, see [Passing information between jobs](https://docs.github.com/en/actions/using-jobs/defining-outputs-for-jobs#overview) and [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onworkflow_calloutputs).

```hljs yaml
name: Reusable workflow

on:
workflow_call:
    # Map the workflow outputs to job outputs
    outputs:
      firstword:
        description: "The first output string"
        value: ${{ jobs.example_job.outputs.output1 }}
      secondword:
        description: "The second output string"
        value: ${{ jobs.example_job.outputs.output2 }}

jobs:
example_job:
    name: Generate output
    runs-on: ubuntu-latest
    # Map the job outputs to step outputs
    outputs:
      output1: ${{ steps.step1.outputs.firstword }}
      output2: ${{ steps.step2.outputs.secondword }}
    steps:
      - id: step1
        run: echo "firstword=hello" >> $GITHUB_OUTPUT
      - id: step2
        run: echo "secondword=world" >> $GITHUB_OUTPUT

```

We can now use the outputs in the caller workflow, in the same way you would use the outputs from a job within the same workflow. We reference the outputs using the names defined at the workflow level in the reusable workflow: `firstword` and `secondword`. In this workflow, `job1` calls the reusable workflow and `job2` prints the outputs from the reusable workflow ("hello world") to standard output in the workflow log.

```hljs yaml
name: Call a reusable workflow and use its outputs

on:
workflow_dispatch:

jobs:
job1:
    uses: octo-org/example-repo/.github/workflows/called-workflow.yml@v1

job2:
    runs-on: ubuntu-latest
    needs: job1
    steps:
      - run: echo ${{ needs.job1.outputs.firstword }} ${{ needs.job1.outputs.secondword }}

```

For more information on using job outputs, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idoutputs). If you want to share something other than a variable (e.g. a build artifact) between workflows, see [Storing and sharing data from a workflow](https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts).

## [Monitoring which workflows are being used](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#monitoring-which-workflows-are-being-used)

Organizations that use GitHub Enterprise Cloud can interact with the audit log via the GitHub REST API to monitor which workflows are being used. For more information, see [the GitHub Enterprise Cloud documentation](https://docs.github.com/en/enterprise-cloud@latest/organizations/keeping-your-organization-secure/managing-security-settings-for-your-organization/reviewing-the-audit-log-for-your-organization#using-the-audit-log-api).

## [Re-running workflows and jobs with reusable workflows](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#re-running-workflows-and-jobs-with-reusable-workflows)

Reusable workflows from public repositories can be referenced using a SHA, a release tag, or a branch name. For more information, see [Reusing workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows#calling-a-reusable-workflow).

When you re-run a workflow that uses a reusable workflow and the reference is not a SHA, there are some behaviors to be aware of:

- Re-running all jobs in a workflow will use the reusable workflow from the specified reference. For more information about re-running all jobs in a workflow, see [Re-running workflows and jobs](https://docs.github.com/en/actions/managing-workflow-runs/re-running-workflows-and-jobs#re-running-all-the-jobs-in-a-workflow).
- Re-running failed jobs or a specific job in a workflow will use the reusable workflow from the same commit SHA of the first attempt. For more information about re-running failed jobs in a workflow, see [Re-running workflows and jobs](https://docs.github.com/en/actions/managing-workflow-runs/re-running-workflows-and-jobs#re-running-failed-jobs-in-a-workflow). For more information about re-running a specific job in a workflow, see [Re-running workflows and jobs](https://docs.github.com/en/actions/managing-workflow-runs/re-running-workflows-and-jobs#re-running-a-specific-job-in-a-workflow).

## [Next steps](https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows\#next-steps)

To continue learning about GitHub Actions, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows).

---


## 5. Building and testing Swift {#section-5}

*Source: [https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-swift](https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-swift)*


# Building and testing Swift

You can create a continuous integration (CI) workflow to build and test your Swift project.

## In this article

## [Introduction](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-swift\#introduction)

This guide shows you how to build and test a Swift package.

GitHub-hosted runners have a tools cache with preinstalled software, and the Ubuntu and macOS runners include the dependencies for building Swift packages. For a full list of up-to-date software and the preinstalled versions of Swift and Xcode, see [About GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-software).

## [Prerequisites](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-swift\#prerequisites)

You should already be familiar with YAML syntax and how it's used with GitHub Actions. For more information, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions).

We recommend that you have a basic understanding of Swift packages. For more information, see [Swift Packages](https://developer.apple.com/documentation/xcode/swift-packages) in the Apple developer documentation.

## [Using a Swift workflow template](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-swift\#using-a-swift-workflow-template)

To get started quickly, add a workflow template to the `.github/workflows` directory of your repository.

GitHub provides a workflow template for Swift that should work for most Swift projects. The subsequent sections of this guide give examples of how you can customize this workflow template.

1. On GitHub, navigate to the main page of the repository.

2. Under your repository name, click **Actions**.



![Screenshot of the tabs for the "github/docs" repository. The "Actions" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)

3. If you already have a workflow in your repository, click **New workflow**.

4. The "Choose a workflow" page shows a selection of recommended workflow templates. Search for "swift".

5. Filter the selection of workflows by clicking **Continuous integration**.

6. On the "Swift" workflow, click **Configure**.

7. Edit the workflow as required. For example, change the branch on which the workflow will run.

8. Click **Commit changes**.

The `swift.yml` workflow file is added to the `.github/workflows` directory of your repository.


## [Specifying a Swift version](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-swift\#specifying-a-swift-version)

To use a specific preinstalled version of Swift on a GitHub-hosted runner, use the `swift-actions/setup-swift` action. This action finds a specific version of Swift from the tools cache on the runner and adds the necessary binaries to `PATH`. These changes will persist for the remainder of a job. For more information, see the [`swift-actions/setup-swift`](https://github.com/marketplace/actions/setup-swift) action.

If you are using a self-hosted runner, you must install your desired Swift versions and add them to `PATH`.

The examples below demonstrate using the `swift-actions/setup-swift` action.

### [Using multiple Swift versions](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-swift\#using-multiple-swift-versions)

You can configure your job to use multiple versions of Swift in a matrix.

```hljs yaml

# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub recommends pinning actions to a commit SHA.
# To get a newer version, you will need to update the SHA.
# You can also reference a tag or branch, but the action may change without warning.

name: Swift

on: [push]

jobs:
  build:
    name: Swift ${{ matrix.swift }} on ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        swift: ["5.2", "5.3"]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf
        with:
          swift-version: ${{ matrix.swift }}
      - uses: actions/checkout@v4
      - name: Build
        run: swift build
      - name: Run tests
        run: swift test

```

### [Using a single specific Swift version](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-swift\#using-a-single-specific-swift-version)

You can configure your job to use a single specific version of Swift, such as `5.3.3`.

```hljs yaml
steps:
  - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf
    with:
      swift-version: "5.3.3"
  - name: Get swift version
    run: swift --version # Swift 5.3.3

```

## [Building and testing your code](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-swift\#building-and-testing-your-code)

You can use the same commands that you use locally to build and test your code using Swift. This example demonstrates how to use `swift build` and `swift test` in a job:

```hljs yaml
steps:
  - uses: actions/checkout@v4
  - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf
    with:
      swift-version: "5.3.3"
  - name: Build
    run: swift build
  - name: Run tests
    run: swift test

```

---


## 6. Building and testing Java with Gradle {#section-6}

*Source: [https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-gradle](https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-gradle)*


# Building and testing Java with Gradle

You can create a continuous integration (CI) workflow in GitHub Actions to build and test your Java project with Gradle.

## In this article

## [Introduction](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-java-with-gradle\#introduction)

This guide shows you how to create a workflow that performs continuous integration (CI) for your Java project using the Gradle build system. The workflow you create will allow you to see when commits to a pull request cause build or test failures against your default branch; this approach can help ensure that your code is always healthy. You can extend your CI workflow to cache files and upload artifacts from a workflow run.

GitHub-hosted runners have a tools cache with pre-installed software, which includes Java Development Kits (JDKs) and Gradle. For a list of software and the pre-installed versions for JDK and Gradle, see [About GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-software).

## [Prerequisites](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-java-with-gradle\#prerequisites)

You should be familiar with YAML and the syntax for GitHub Actions. For more information, see:

- [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions)
- [Writing workflows](https://docs.github.com/en/actions/learn-github-actions)

We recommend that you have a basic understanding of Java and the Gradle framework. For more information, see the [Gradle User Manual](https://docs.gradle.org/current/userguide/userguide.html).

## [Using a Gradle workflow template](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-java-with-gradle\#using-a-gradle-workflow-template)

To get started quickly, add a workflow template to the `.github/workflows` directory of your repository.

GitHub provides a workflow template for Gradle that should work for most Java with Gradle projects. The subsequent sections of this guide give examples of how you can customize this workflow template.

01. On GitHub, navigate to the main page of the repository.

02. Under your repository name, click **Actions**.



    ![Screenshot of the tabs for the "github/docs" repository. The "Actions" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)

03. If you already have a workflow in your repository, click **New workflow**.

04. The "Choose a workflow" page shows a selection of recommended workflow templates. Search for "Java with Gradle".

05. On the "Java with Gradle" workflow, click **Configure**.
    This workflow performs the following steps:

06. Checks out a copy of project's repository.

07. Sets up the Java JDK.

08. Sets up the Gradle environment. The [`gradle/actions/setup-gradle`](https://github.com/gradle/actions) action takes care of caching state between workflow runs, and provides a detailed summary of all Gradle executions.

09. The "Build with Gradle" step executes the `build` task using the [Gradle Wrapper](https://docs.gradle.org/current/userguide/gradle_wrapper.html).

10. Edit the workflow as required. For example, change the Java version.



    Note







- This workflow template contains an action that is not certified by GitHub. Actions provided by third parties are governed by separate terms of service, privacy policy, and support documentation.
- If you use actions from third parties you should use a version specified by a commit SHA. If the action is revised and you want to use the newer version, you will need to update the SHA. You can specify a version by referencing a tag or a branch, however the action may change without warning. For more information, see [Security hardening for GitHub Actions](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#using-third-party-actions).

11. Click **Commit changes**.

    The `gradle.yml` workflow file is added to the `.github/workflows` directory of your repository.


### [Specifying the Java version and architecture](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-java-with-gradle\#specifying-the-java-version-and-architecture)

The workflow template sets up the `PATH` to contain OpenJDK 8 for the x64 platform. If you want to use a different version of Java, or target a different architecture ( `x64` or `x86`), you can use the `setup-java` action to choose a different Java runtime environment.

For example, to use version 11 of the JDK provided by Adoptium for the x64 platform, you can use the `setup-java` action and configure the `java-version`, `distribution` and `architecture` parameters to `'11'`, `'temurin'` and `x64`.

```hljs yaml
steps:
  - uses: actions/checkout@v4
  - name: Set up JDK 11 for x64
    uses: actions/setup-java@v4
    with:
      java-version: '11'
      distribution: 'temurin'
      architecture: x64

```

For more information, see the [`setup-java`](https://github.com/actions/setup-java) action.

## [Building and testing your code](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-java-with-gradle\#building-and-testing-your-code)

You can use the same commands that you use locally to build and test your code.

The workflow template will run the `build` task by default. In the default Gradle configuration, this command will download dependencies, build classes, run tests, and package classes into their distributable format, for example, a JAR file.

If you use different commands to build your project, or you want to use a different task, you can specify those. For example, you may want to run the `package` task that's configured in your `ci.gradle` file.

```hljs yaml
steps:
  - uses: actions/checkout@v4
  - uses: actions/setup-java@v4
    with:
      java-version: '17'
      distribution: 'temurin'

  - name: Setup Gradle
    uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0

  - name: Build with Gradle
    run: ./gradlew -b ci.gradle package

```

## [Caching dependencies](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-java-with-gradle\#caching-dependencies)

Your build dependencies can be cached to speed up your workflow runs. After a successful run, `gradle/actions/setup-gradle` caches important parts of the Gradle user home directory. In future jobs, the cache will be restored so that build scripts won't need to be recompiled and dependencies won't need to be downloaded from remote package repositories.

Caching is enabled by default when using the `gradle/actions/setup-gradle` action. For more information, see [`gradle/actions/setup-gradle`](https://github.com/gradle/actions/blob/main/setup-gradle/README.md#caching-build-state-between-jobs).

## [Packaging workflow data as artifacts](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-java-with-gradle\#packaging-workflow-data-as-artifacts)

After your build has succeeded and your tests have passed, you may want to upload the resulting Java packages as a build artifact. This will store the built packages as part of the workflow run, and allow you to download them. Artifacts can help you test and debug pull requests in your local environment before they're merged. For more information, see [Storing and sharing data from a workflow](https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts).

Gradle will usually create output files like JARs, EARs, or WARs in the `build/libs` directory. You can upload the contents of that directory using the `upload-artifact` action.

```hljs yaml
steps:
  - uses: actions/checkout@v4
  - uses: actions/setup-java@v4
    with:
      java-version: '17'
      distribution: 'temurin'

  - name: Setup Gradle
    uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0

  - name: Build with Gradle
    run: ./gradlew build

  - name: Upload build artifacts
    uses: actions/upload-artifact@v4
    with:
      name: Package
      path: build/libs

```

---


## 7. Deploying with GitHub Actions {#section-7}

*Source: [https://docs.github.com/en/actions/deployment/about-deployments/deploying-with-github-actions](https://docs.github.com/en/actions/deployment/about-deployments/deploying-with-github-actions)*


# Deploying with GitHub Actions

Learn how to control deployments with features like environments and concurrency.

## In this article

## [Introduction](https://docs.github.com/en/actions/concepts/use-cases/deploying-with-github-actions\#introduction)

GitHub Actions offers features that let you control deployments. You can:

- Trigger workflows with a variety of events.
- Configure environments to set rules before a job can proceed and to limit access to secrets.
- Use concurrency to control the number of deployments running at a time.

For more information about continuous deployment, see [About continuous deployment with GitHub Actions](https://docs.github.com/en/actions/deployment/about-deployments/about-continuous-deployment).

## [Prerequisites](https://docs.github.com/en/actions/concepts/use-cases/deploying-with-github-actions\#prerequisites)

You should be familiar with the syntax for GitHub Actions. For more information, see [Writing workflows](https://docs.github.com/en/actions/learn-github-actions).

## [Triggering your deployment](https://docs.github.com/en/actions/concepts/use-cases/deploying-with-github-actions\#triggering-your-deployment)

You can use a variety of events to trigger your deployment workflow. Some of the most common are: `pull_request`, `push`, and `workflow_dispatch`.

For example, a workflow with the following triggers runs whenever:

- There is a push to the `main` branch.
- A pull request targeting the `main` branch is opened, synchronized, or reopened.
- Someone manually triggers it.

```hljs yaml
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:

```

For more information, see [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows).

## [Using environments](https://docs.github.com/en/actions/concepts/use-cases/deploying-with-github-actions\#using-environments)

Environments are used to describe a general deployment target like `production`, `staging`, or `development`. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, see [Managing environments for deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/managing-environments-for-deployment).

## [Using concurrency](https://docs.github.com/en/actions/concepts/use-cases/deploying-with-github-actions\#using-concurrency)

Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time. You can use concurrency so that an environment has a maximum of one deployment in progress and one deployment pending at a time. For more information about concurrency, see [Control the concurrency of workflows and jobs](https://docs.github.com/en/actions/using-jobs/using-concurrency).

Note

`concurrency` and `environment` are not connected. The concurrency value can be any string; it does not need to be an environment name. Additionally, if another workflow uses the same environment but does not specify concurrency, that workflow will not be subject to any concurrency rules.

For example, when the following workflow runs, it will be paused with the status `pending` if any job or workflow that uses the `production` concurrency group is in progress. It will also cancel any job or workflow that uses the `production` concurrency group and has the status `pending`. This means that there will be a maximum of one running and one pending job or workflow in that uses the `production` concurrency group.

```hljs yaml
name: Deployment

concurrency: production

on:
  push:
    branches:
      - main

jobs:
  deployment:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: deploy
        # ...deployment-specific steps

```

You can also specify concurrency at the job level. This will allow other jobs in the workflow to proceed even if the concurrent job is `pending`.

```hljs yaml
name: Deployment

on:
  push:
    branches:
      - main

jobs:
  deployment:
    runs-on: ubuntu-latest
    environment: production
    concurrency: production
    steps:
      - name: deploy
        # ...deployment-specific steps

```

You can also use `cancel-in-progress` to cancel any currently running job or workflow in the same concurrency group.

```hljs yaml
name: Deployment

concurrency:
  group: production
  cancel-in-progress: true

on:
  push:
    branches:
      - main

jobs:
  deployment:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: deploy
        # ...deployment-specific steps

```

For guidance on writing deployment-specific steps, see [Finding deployment examples](https://docs.github.com/en/actions/concepts/use-cases/deploying-with-github-actions#finding-deployment-examples).

## [Viewing deployment history](https://docs.github.com/en/actions/concepts/use-cases/deploying-with-github-actions\#viewing-deployment-history)

When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. For more information about viewing deployments to environments, see [Viewing deployment history](https://docs.github.com/en/actions/deployment/managing-your-deployments/viewing-deployment-history).

## [Monitoring workflow runs](https://docs.github.com/en/actions/concepts/use-cases/deploying-with-github-actions\#monitoring-workflow-runs)

Every workflow run generates a real-time graph that illustrates the run progress. You can use this graph to monitor and debug deployments. For more information see, [Using the visualization graph](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/using-the-visualization-graph).

You can also view the logs of each workflow run and the history of workflow runs. For more information, see [Viewing workflow run history](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/viewing-workflow-run-history).

## [Tracking deployments through apps](https://docs.github.com/en/actions/concepts/use-cases/deploying-with-github-actions\#tracking-deployments-through-apps)

If your personal account or organization on GitHub is integrated with Microsoft Teams or Slack, you can track deployments that use environments through Microsoft Teams or Slack. For example, you can receive notifications through the app when a deployment is pending approval, when a deployment is approved, or when the deployment status changes. For more information about integrating Microsoft Teams or Slack, see [Featured GitHub integrations](https://docs.github.com/en/get-started/exploring-integrations/github-extensions-and-integrations#team-communication-tools).

You can also build an app that uses deployment and deployment status webhooks to track deployments. When a workflow job that references an environment runs, it creates a deployment object with the `environment` property set to the name of your environment. As the workflow progresses, it also creates deployment status objects with the `environment` property set to the name of your environment, the `environment_url` property set to the URL for environment (if specified in the workflow), and the `state` property set to the status of the job. For more information, see [GitHub Apps documentation](https://docs.github.com/en/apps) and [Webhook events and payloads](https://docs.github.com/en/webhooks-and-events/webhooks/webhook-events-and-payloads#deployment).

## [Choosing a runner](https://docs.github.com/en/actions/concepts/use-cases/deploying-with-github-actions\#choosing-a-runner)

You can run your deployment workflow on GitHub-hosted runners or on self-hosted runners. Traffic from GitHub-hosted runners can come from a [wide range of network addresses](https://docs.github.com/en/rest/meta/meta#get-github-meta-information). If you are deploying to an internal environment and your company restricts external traffic into private networks, GitHub Actions workflows running on GitHub-hosted runners may not be able to communicate with your internal services or resources. To overcome this, you can host your own runners. For more information, see [About self-hosted runners](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners) and [About GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners).

## [Displaying a status badge](https://docs.github.com/en/actions/concepts/use-cases/deploying-with-github-actions\#displaying-a-status-badge)

You can use a status badge to display the status of your deployment workflow. A status badge shows whether a workflow is currently failing or passing. A common place to add a status badge is in the `README.md` file of your repository, but you can add it to any web page you'd like. By default, badges display the status of your default branch. If there are no workflow runs on your default branch, it will display the status of the most recent run across all branches. You can display the status of a workflow run for a specific branch or event using the `branch` and `event` query parameters in the URL.

![Screenshot of a workflow status badge. From right to left it shows: the GitHub logo, workflow name ("GitHub Actions Demo"), and status ("passing").](https://docs.github.com/assets/cb-16218/images/help/repository/actions-workflow-status-badge.png)

For more information, see [Adding a workflow status badge](https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/adding-a-workflow-status-badge).

## [Finding deployment examples](https://docs.github.com/en/actions/concepts/use-cases/deploying-with-github-actions\#finding-deployment-examples)

This article demonstrated features of GitHub Actions that you can add to your deployment workflows.

GitHub offers deployment workflow templates for several popular services, such as Azure Web App. To learn how to get started using a workflow template, see [Using workflow templates](https://docs.github.com/en/actions/learn-github-actions/using-starter-workflows) or [browse the full list of deployment workflow templates](https://github.com/actions/starter-workflows/tree/main/deployments). You can also check out our more detailed guides for specific deployment workflows, such as [Deploying Node.js to Azure App Service](https://docs.github.com/en/actions/deployment/deploying-to-your-cloud-provider/deploying-to-azure/deploying-nodejs-to-azure-app-service).

Many service providers also offer actions on GitHub Marketplace for deploying to their service. For the full list, see [GitHub Marketplace](https://github.com/marketplace?category=deployment&type=actions).

---


## 8. Storing and sharing data from a workflow {#section-8}

*Source: [https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts](https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts)*


# Storing and sharing data from a workflow

Artifacts allow you to share data between jobs in a workflow and store data once that workflow has completed.

## In this article

## [About workflow artifacts](https://docs.github.com/en/actions/how-tos/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow\#about-workflow-artifacts)

Artifacts allow you to persist data after a job has completed, and share that data with another job in the same workflow. An artifact is a file or collection of files produced during a workflow run. For example, you can use artifacts to save your build and test output after a workflow run has ended. All actions and workflows called within a run have write access to that run's artifacts.

By default, GitHub stores build logs and artifacts for 90 days, and this retention period can be customized. For more information, see [Usage limits, billing, and administration](https://docs.github.com/en/actions/learn-github-actions/usage-limits-billing-and-administration#artifact-and-log-retention-policy). The retention period for a pull request restarts each time someone pushes a new commit to the pull request.

These are some of the common artifacts that you can upload:

- Log files and core dumps
- Test results, failures, and screenshots
- Binary or compressed files
- Stress test performance output and code coverage results

Storing artifacts uses storage space on GitHub. GitHub Actions usage is free for standard GitHub-hosted runners in public repositories, and for self-hosted runners. See [Choosing the runner for a job](https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/choosing-the-runner-for-a-job#standard-github-hosted-runners-for-public-repositories). For private repositories, each GitHub account receives a quota of free minutes and storage for use with GitHub-hosted runners, depending on the account's plan. Any usage beyond the included amounts is billed to your account. For more information, see [About billing for GitHub Actions](https://docs.github.com/en/billing/managing-billing-for-github-actions).

Artifacts are uploaded during a workflow run, and you can view an artifact's name and size in the UI. When an artifact is downloaded using the GitHub UI, all files that were individually uploaded as part of the artifact get zipped together into a single file. This means that billing is calculated based on the size of the uploaded artifact and not the size of the zip file.

GitHub provides two actions that you can use to upload and download build artifacts. For more information, see the [upload-artifact](https://github.com/actions/upload-artifact) and [download-artifact](https://github.com/actions/download-artifact) actions.

To share data between jobs:

- **Uploading files:** Give the uploaded file a name and upload the data before the job ends.
- **Downloading files:** You can only download artifacts that were uploaded during the same workflow run. When you download a file, you can reference it by name.

The steps of a job share the same environment on the runner machine, but run in their own individual processes. To pass data between steps in a job, you can use inputs and outputs. For more information about inputs and outputs, see [Metadata syntax reference](https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions).

## [Comparing artifacts and dependency caching](https://docs.github.com/en/actions/how-tos/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow\#comparing-artifacts-and-dependency-caching)

Artifacts and caching are similar because they provide the ability to store files on GitHub, but each feature offers different use cases and cannot be used interchangeably.

- Use caching when you want to reuse files that don't change often between jobs or workflow runs, such as build dependencies from a package management system.
- Use artifacts when you want to save files produced by a job to view after a workflow run has ended, such as built binaries or build logs.

For more information on dependency caching, see [Caching dependencies to speed up workflows](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows#comparing-artifacts-and-dependency-caching).

## [Uploading build and test artifacts](https://docs.github.com/en/actions/how-tos/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow\#uploading-build-and-test-artifacts)

You can create a continuous integration (CI) workflow to build and test your code. For more information about using GitHub Actions to perform CI, see [About continuous integration with GitHub Actions](https://docs.github.com/en/actions/automating-builds-and-tests/about-continuous-integration).

The output of building and testing your code often produces files you can use to debug test failures and production code that you can deploy. You can configure a workflow to build and test the code pushed to your repository and report a success or failure status. You can upload the build and test output to use for deployments, debugging failed tests or crashes, and viewing test suite coverage.

You can use the `upload-artifact` action to upload artifacts. When uploading an artifact, you can specify a single file or directory, or multiple files or directories. You can also exclude certain files or directories, and use wildcard patterns. We recommend that you provide a name for an artifact, but if no name is provided then `artifact` will be used as the default name. For more information on syntax, see the [actions/upload-artifact](https://github.com/actions/upload-artifact) action.

### [Example](https://docs.github.com/en/actions/how-tos/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow\#example)

For example, your repository or a web application might contain SASS and TypeScript files that you must convert to CSS and JavaScript. Assuming your build configuration outputs the compiled files in the `dist` directory, you would deploy the files in the `dist` directory to your web application server if all tests completed successfully.

```hljs text
|-- hello-world (repository)
|    dist
|    tests
|    src
|        sass/app.scss
|        app.ts
|    output
|        test
|

```

This example shows you how to create a workflow for a Node.js project that builds the code in the `src` directory and runs the tests in the `tests` directory. You can assume that running `npm test` produces a code coverage report named `code-coverage.html` stored in the `output/test/` directory.

The workflow uploads the production artifacts in the `dist` directory, but excludes any markdown files. It also uploads the `code-coverage.html` report as another artifact.

```hljs yaml
name: Node CI

on: [push]

jobs:
  build_and_test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: npm install, build, and test
        run: |
          npm install
          npm run build --if-present
          npm test
      - name: Archive production artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-without-markdown
          path: |
            dist
            !dist/**/*.md
      - name: Archive code coverage results
        uses: actions/upload-artifact@v4
        with:
          name: code-coverage-report
          path: output/test/code-coverage.html

```

## [Generating artifact attestations for builds](https://docs.github.com/en/actions/how-tos/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow\#generating-artifact-attestations-for-builds)

Artifact attestations enable you to create unfalsifiable provenance and integrity guarantees for the software you build. In turn, people who consume your software can verify where and how your software was built.

When you generate artifact attestations with your software, you create cryptographically signed claims that establish your build's provenance and include the following information:

- A link to the workflow associated with the artifact.
- The repository, organization, environment, commit SHA, and triggering event for the artifact.
- Other information from the OIDC token used to establish provenance. For more information, see [About security hardening with OpenID Connect](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/about-security-hardening-with-openid-connect).

You can also generate artifact attestations that include an associated software bill of materials (SBOM). Associating your builds with a list of the open source dependencies used in them provides transparency and enables consumers to comply with data protection standards.

You can access attestations after a build run, underneath the list of the artifacts the build produced.

For more information, see [Using artifact attestations to establish provenance for builds](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).

## [Configuring a custom artifact retention period](https://docs.github.com/en/actions/how-tos/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow\#configuring-a-custom-artifact-retention-period)

You can define a custom retention period for individual artifacts created by a workflow. When using a workflow to create a new artifact, you can use `retention-days` with the `upload-artifact` action. This example demonstrates how to set a custom retention period of 5 days for the artifact named `my-artifact`:

```hljs yaml
  - name: 'Upload Artifact'
    uses: actions/upload-artifact@v4
    with:
      name: my-artifact
      path: my_file.txt
      retention-days: 5

```

The `retention-days` value cannot exceed the retention limit set by the repository, organization, or enterprise.

## [Downloading or deleting artifacts](https://docs.github.com/en/actions/how-tos/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow\#downloading-or-deleting-artifacts)

During a workflow run, you can use the [`download-artifact`](https://github.com/actions/download-artifact) action to download artifacts that were previously uploaded in the same workflow run.

After a workflow run has been completed, you can download or delete artifacts on GitHub or using the REST API. For more information, see [Downloading workflow artifacts](https://docs.github.com/en/actions/managing-workflow-runs/downloading-workflow-artifacts), [Removing workflow artifacts](https://docs.github.com/en/actions/managing-workflow-runs/removing-workflow-artifacts), and [REST API endpoints for GitHub Actions artifacts](https://docs.github.com/en/rest/actions/artifacts).

### [Downloading artifacts during a workflow run](https://docs.github.com/en/actions/how-tos/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow\#downloading-artifacts-during-a-workflow-run)

The [`actions/download-artifact`](https://github.com/actions/download-artifact) action can be used to download previously uploaded artifacts during a workflow run.

Note

If you want to download artifacts from a different workflow or workflow run, you need to supply a token and run identifier. See [Download Artifacts from other Workflow Runs or Repositories](https://github.com/actions/download-artifact?tab=readme-ov-file#download-artifacts-from-other-workflow-runs-or-repositories) in the documentation for the `download-artifact` action.

Specify an artifact's name to download an individual artifact. If you uploaded an artifact without specifying a name, the default name is `artifact`.

```hljs yaml
- name: Download a single artifact
  uses: actions/download-artifact@v4
  with:
    name: my-artifact

```

You can also download all artifacts in a workflow run by not specifying a name. This can be useful if you are working with lots of artifacts.

```hljs yaml
- name: Download all workflow run artifacts
  uses: actions/download-artifact@v4

```

If you download all workflow run's artifacts, a directory for each artifact is created using its name.

For more information on syntax, see the [actions/download-artifact](https://github.com/actions/download-artifact) action.

## [Validating artifacts](https://docs.github.com/en/actions/how-tos/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow\#validating-artifacts)

Every time the upload-artifact action is used it returns an output called `digest`. This is a SHA256 digest of the Artifact you uploaded during a workflow run.

When the download-artifact action is then used to download that artifact, it automatically calculates the digest for that downloaded artifact and validates that it matches the output from the upload-artifact step.

If the digest does not match, the run will display a warning in the UI and in the job logs.

To view the SHA256 digest you can open the logs for the upload-artifact job or check in the Artifact output that appears in the workflow run UI.

## [Passing data between jobs in a workflow](https://docs.github.com/en/actions/how-tos/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow\#passing-data-between-jobs-in-a-workflow)

You can use the `upload-artifact` and `download-artifact` actions to share data between jobs in a workflow. This example workflow illustrates how to pass data between jobs in the same workflow. For more information, see the [actions/upload-artifact](https://github.com/actions/upload-artifact) and [download-artifact](https://github.com/actions/download-artifact) actions.

Jobs that are dependent on a previous job's artifacts must wait for the dependent job to complete successfully. This workflow uses the `needs` keyword to ensure that `job_1`, `job_2`, and `job_3` run sequentially. For example, `job_2` requires `job_1` using the `needs: job_1` syntax.

Job 1 performs these steps:

- Performs a math calculation and saves the result to a text file called `math-homework.txt`.
- Uses the `upload-artifact` action to upload the `math-homework.txt` file with the artifact name `homework_pre`.

Job 2 uses the result in the previous job:

- Downloads the `homework_pre` artifact uploaded in the previous job. By default, the `download-artifact` action downloads artifacts to the workspace directory that the step is executing in. You can use the `path` input parameter to specify a different download directory.
- Reads the value in the `math-homework.txt` file, performs a math calculation, and saves the result to `math-homework.txt` again, overwriting its contents.
- Uploads the `math-homework.txt` file. As artifacts are considered immutable in `v4`, the artifact is passed a different input, `homework_final`, as a name.

Job 3 displays the result uploaded in the previous job:

- Downloads the `homework_final` artifact from Job 2.
- Prints the result of the math equation to the log.

The full math operation performed in this workflow example is `(3 + 7) x 9 = 90`.

```hljs yaml
name: Share data between jobs

on: [push]

jobs:
  job_1:
    name: Add 3 and 7
    runs-on: ubuntu-latest
    steps:
      - shell: bash
        run: |
          expr 3 + 7 > math-homework.txt
      - name: Upload math result for job 1
        uses: actions/upload-artifact@v4
        with:
          name: homework_pre
          path: math-homework.txt

  job_2:
    name: Multiply by 9
    needs: job_1
    runs-on: windows-latest
    steps:
      - name: Download math result for job 1
        uses: actions/download-artifact@v4
        with:
          name: homework_pre
      - shell: bash
        run: |
          value=`cat math-homework.txt`
          expr $value \* 9 > math-homework.txt
      - name: Upload math result for job 2
        uses: actions/upload-artifact@v4
        with:
          name: homework_final
          path: math-homework.txt

  job_3:
    name: Display results
    needs: job_2
    runs-on: macOS-latest
    steps:
      - name: Download math result for job 2
        uses: actions/download-artifact@v4
        with:
          name: homework_final
      - name: Print the final result
        shell: bash
        run: |
          value=`cat math-homework.txt`
          echo The result is $value

```

The workflow run will archive any artifacts that it generated. For more information on downloading archived artifacts, see [Downloading workflow artifacts](https://docs.github.com/en/actions/managing-workflow-runs/downloading-workflow-artifacts).

## [Artifacts from deleted workflow runs](https://docs.github.com/en/actions/how-tos/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow\#artifacts-from-deleted-workflow-runs)

When a workflow run is deleted all artifacts associated with the run are also deleted from storage. You can delete a workflow run using the GitHub Actions UI, the REST API, or using the GitHub CLI, see: [Deleting a workflow run](https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/deleting-a-workflow-run), [Delete a workflow run](https://docs.github.com/en/rest/actions/workflow-runs?apiVersion=2022-11-28#delete-a-workflow-run), or [gh run delete](https://cli.github.com/manual/gh_run_delete).

## [Further reading](https://docs.github.com/en/actions/how-tos/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow\#further-reading)

- [About billing for GitHub Actions](https://docs.github.com/en/billing/managing-billing-for-github-actions).

---


## 9. Use cases and examples {#section-9}

*Source: [https://docs.github.com/en/actions/examples](https://docs.github.com/en/actions/examples)*


# Use cases and examples

Example workflows that demonstrate the features of GitHub Actions.

## [Building and testing](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing)

You can automatically build and test your projects with GitHub Actions.

## [Deploying](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/deploying)

Automatically deploy projects with GitHub Actions.

## [Publishing packages](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/publishing-packages)

You can automatically publish packages using GitHub Actions.

## [Managing projects](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/project-management)

You can automatically manage your issues and pull requests using GitHub Actions workflows.

## [Using containerized services](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/using-containerized-services)

You can use containerized services in your GitHub Actions workflows.

---


## 10. Building and testing Node.js {#section-10}

*Source: [https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs](https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-nodejs)*


# Building and testing Node.js

You can create a continuous integration (CI) workflow to build and test your Node.js project.

## In this article

## [Introduction](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-nodejs\#introduction)

This guide shows you how to create a continuous integration (CI) workflow that builds and tests Node.js code. If your CI tests pass, you may want to deploy your code or publish a package.

## [Prerequisites](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-nodejs\#prerequisites)

We recommend that you have a basic understanding of Node.js, YAML, workflow configuration options, and how to create a workflow file. For more information, see:

- [Writing workflows](https://docs.github.com/en/actions/learn-github-actions)
- [Getting started with Node.js](https://nodejs.org/en/docs/guides/getting-started-guide/)

## [Using a Node.js workflow template](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-nodejs\#using-a-nodejs-workflow-template)

To get started quickly, add a workflow template to the `.github/workflows` directory of your repository.

GitHub provides a workflow template for Node.js that should work for most Node.js projects. The subsequent sections of this guide give examples of how you can customize this workflow template.

1. On GitHub, navigate to the main page of the repository.

2. Under your repository name, click **Actions**.



![Screenshot of the tabs for the "github/docs" repository. The "Actions" tab is highlighted with an orange outline.](https://docs.github.com/assets/cb-12958/images/help/repository/actions-tab-global-nav-update.png)

3. If you already have a workflow in your repository, click **New workflow**.

4. The "Choose a workflow" page shows a selection of recommended workflow templates. Search for "Node.js".

5. Filter the selection of workflows by clicking **Continuous integration**.

6. On the "Node.js" workflow, click **Configure**.

7. Edit the workflow as required. For example, change the Node versions you want to use.

8. Click **Commit changes**.

The `node.js.yml` workflow file is added to the `.github/workflows` directory of your repository.


## [Specifying the Node.js version](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-nodejs\#specifying-the-nodejs-version)

The easiest way to specify a Node.js version is by using the `setup-node` action provided by GitHub. For more information see, [`setup-node`](https://github.com/actions/setup-node/).

The `setup-node` action takes a Node.js version as an input and configures that version on the runner. The `setup-node` action finds a specific version of Node.js from the tools cache on each runner and adds the necessary binaries to `PATH`, which persists for the rest of the job. Using the `setup-node` action is the recommended way of using Node.js with GitHub Actions because it ensures consistent behavior across different runners and different versions of Node.js. If you are using a self-hosted runner, you must install Node.js and add it to `PATH`.

The workflow template includes a matrix strategy that builds and tests your code with the Node.js versions listed in `node-version`. The 'x' in the version number is a wildcard character that matches the latest minor and patch release available for a version. Each version of Node.js specified in the `node-version` array creates a job that runs the same steps.

Each job can access the value defined in the matrix `node-version` array using the `matrix` context. The `setup-node` action uses the context as the `node-version` input. The `setup-node` action configures each job with a different Node.js version before building and testing code. For more information about matrix strategies and contexts, see [Workflow syntax for GitHub Actions](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstrategymatrix) and [Contexts reference](https://docs.github.com/en/actions/learn-github-actions/contexts).

```hljs yaml
strategy:
  matrix:
    node-version: ['18.x', '20.x']

steps:
- uses: actions/checkout@v4
- name: Use Node.js ${{ matrix.node-version }}
  uses: actions/setup-node@v4
  with:
    node-version: ${{ matrix.node-version }}

```

Alternatively, you can build and test with exact Node.js versions.

```hljs yaml
strategy:
  matrix:
    node-version: ['10.17.0', '17.9.0']

```

Or, you can build and test using a single version of Node.js too.

```hljs yaml
name: Node.js CI

on: [push]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'
      - run: npm ci
      - run: npm run build --if-present
      - run: npm test

```

If you don't specify a Node.js version, GitHub uses the environment's default Node.js version.
For more information, see [About GitHub-hosted runners](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners#supported-software).

## [Installing dependencies](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-nodejs\#installing-dependencies)

GitHub-hosted runners have npm and Yarn dependency managers installed. You can use npm and Yarn to install dependencies in your workflow before building and testing your code. The Windows and Linux GitHub-hosted runners also have Grunt, Gulp, and Bower installed.

You can also cache dependencies to speed up your workflow. For more information, see [Caching dependencies to speed up workflows](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows).

### [Example using npm](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-nodejs\#example-using-npm)

This example installs the versions in the `package-lock.json` or `npm-shrinkwrap.json` file and prevents updates to the lock file. Using `npm ci` is generally faster than running `npm install`. For more information, see [`npm ci`](https://docs.npmjs.com/cli/ci.html) and [Introducing `npm ci` for faster, more reliable builds](https://blog.npmjs.org/post/171556855892/introducing-npm-ci-for-faster-more-reliable).

```hljs yaml
steps:
- uses: actions/checkout@v4
- name: Use Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20.x'
- name: Install dependencies
  run: npm ci

```

Using `npm install` installs the dependencies defined in the `package.json` file. For more information, see [`npm install`](https://docs.npmjs.com/cli/install).

```hljs yaml
steps:
- uses: actions/checkout@v4
- name: Use Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20.x'
- name: Install dependencies
  run: npm install

```

### [Example using Yarn](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-nodejs\#example-using-yarn)

This example installs the dependencies defined in the `yarn.lock` file and prevents updates to the `yarn.lock` file. For more information, see [`yarn install`](https://yarnpkg.com/en/docs/cli/install).

```hljs yaml
steps:
- uses: actions/checkout@v4
- name: Use Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20.x'
- name: Install dependencies
  run: yarn --frozen-lockfile

```

Alternatively, you can install the dependencies defined in the `package.json` file.

```hljs yaml
steps:
- uses: actions/checkout@v4
- name: Use Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20.x'
- name: Install dependencies
  run: yarn

```

### [Example using a private registry and creating the .npmrc file](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-nodejs\#example-using-a-private-registry-and-creating-the-npmrc-file)

You can use the `setup-node` action to create a local `.npmrc` file on the runner that configures the default registry and scope. The `setup-node` action also accepts an authentication token as input, used to access private registries or publish node packages. For more information, see [`setup-node`](https://github.com/actions/setup-node/).

To authenticate to your private registry, you'll need to store your npm authentication token as a secret. For example, create a repository secret called `NPM_TOKEN`. For more information, see [Using secrets in GitHub Actions](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions).

In the example below, the secret `NPM_TOKEN` stores the npm authentication token. The `setup-node` action configures the `.npmrc` file to read the npm authentication token from the `NODE_AUTH_TOKEN` environment variable. When using the `setup-node` action to create an `.npmrc` file, you must set the `NODE_AUTH_TOKEN` environment variable with the secret that contains your npm authentication token.

Before installing dependencies, use the `setup-node` action to create the `.npmrc` file. The action has two input parameters. The `node-version` parameter sets the Node.js version, and the `registry-url` parameter sets the default registry. If your package registry uses scopes, you must use the `scope` parameter. For more information, see [`npm-scope`](https://docs.npmjs.com/misc/scope).

```hljs yaml
steps:
- uses: actions/checkout@v4
- name: Use Node.js
  uses: actions/setup-node@v4
  with:
    always-auth: true
    node-version: '20.x'
    registry-url: https://registry.npmjs.org
    scope: '@octocat'
- name: Install dependencies
  run: npm ci
  env:
    NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

```

The example above creates an `.npmrc` file with the following contents:

```hljs shell
//registry.npmjs.org/:_authToken=${NODE_AUTH_TOKEN}
@octocat:registry=https://registry.npmjs.org/
always-auth=true

```

### [Example caching dependencies](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-nodejs\#example-caching-dependencies)

You can cache and restore the dependencies using the [`setup-node` action](https://github.com/actions/setup-node).

The following example caches dependencies for npm.

```hljs yaml
steps:
- uses: actions/checkout@v4
- uses: actions/setup-node@v4
  with:
    node-version: '20'
    cache: 'npm'
- run: npm install
- run: npm test

```

The following example caches dependencies for Yarn.

```hljs yaml
steps:
- uses: actions/checkout@v4
- uses: actions/setup-node@v4
  with:
    node-version: '20'
    cache: 'yarn'
- run: yarn
- run: yarn test

```

The following example caches dependencies for pnpm (v6.10+).

```hljs yaml
# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# NOTE: pnpm caching support requires pnpm version >= 6.10.0

steps:
- uses: actions/checkout@v4
- uses: pnpm/action-setup@0609f0983b7a228f052f81ef4c3d6510cae254ad
  with:
    version: 6.10.0
- uses: actions/setup-node@v4
  with:
    node-version: '20'
    cache: 'pnpm'
- run: pnpm install
- run: pnpm test

```

If you have a custom requirement or need finer controls for caching, you can use the [`cache` action](https://github.com/marketplace/actions/cache). For more information, see [Caching dependencies to speed up workflows](https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows).

## [Building and testing your code](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-nodejs\#building-and-testing-your-code)

You can use the same commands that you use locally to build and test your code. For example, if you run `npm run build` to run build steps defined in your `package.json` file and `npm test` to run your test suite, you would add those commands in your workflow file.

```hljs yaml
steps:
- uses: actions/checkout@v4
- name: Use Node.js
  uses: actions/setup-node@v4
  with:
    node-version: '20.x'
- run: npm install
- run: npm run build --if-present
- run: npm test

```

## [Packaging workflow data as artifacts](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-nodejs\#packaging-workflow-data-as-artifacts)

You can save artifacts from your build and test steps to view after a job completes. For example, you may need to save log files, core dumps, test results, or screenshots. For more information, see [Storing and sharing data from a workflow](https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts).

## [Publishing to package registries](https://docs.github.com/en/actions/how-tos/use-cases-and-examples/building-and-testing/building-and-testing-nodejs\#publishing-to-package-registries)

You can configure your workflow to publish your Node.js package to a package registry after your CI tests pass. For more information about publishing to npm and GitHub Packages, see [Publishing Node.js packages](https://docs.github.com/en/actions/publishing-packages/publishing-nodejs-packages).

---
